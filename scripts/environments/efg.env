#!/usr/local/bin/bash

#LICENSE
#
#  Copyright (c) 1999-2009 The European Bioinformatics Institute and
#  Genome Research Limited.  All rights reserved.
#
#  This software is distributed under a modified Apache license.
#  For license details, please see
#
#    http://www.ensembl.org/info/about/code_licence.html
#
#CONTACT
#
#  Please email comments or questions to the public Ensembl
#  developers list at <ensembl-dev@ebi.ac.uk>.
#
#  Questions may also be sent to the Ensembl help desk at
#  <helpdesk@ensembl.org>.


#Enter subshell here so we don't exit from login shell
bash

echo "Setting up the Ensembl Function Genomics environment..." 
#add alias efg='. ~/path/to/your/ensembl-functgenomics/scripts/environments/efg.env' to your .bashrc


#Do findbin here

#Nope this only does the pwd from whereit is called
#bin=$( readlink -f -- "$( dirname -- "$0" )" )
#Nope, this return the pwd appended with /bash
#bin=$( readlink -f -- "${0%/*}" ) 
#Nope this is just pwd again!
#bin=$(cd -- "$(dirname "$0")" && pwd) 
#None of the above work when sourcing!!

#echo "bin is bin $bin " 

# To do

# 1 Make template file for efg.config to avoid overwriting custom conf on checkout

# 2 Rename all private methods to start with _ or lcfirst, for EFGHelp filtering
#   _ should never be called from command line, as they are dependant on caller context
#   lcfirst can be, but may not have -h option
#   All ucfirst should have -h option



funcs_file="$SRC/ensembl-functgenomics/scripts/environments/funcs.sh"

if [ -z "$SRC" ]; then
	echo 'You have not defined $SRC in your .bashrc'
	echo 'Adding eFG setup to .bashrc'
	
	echo "Cannot yet findbin when sourcing in bash, add manually"
	exit 1
else
	#Now we need to check for ensembl-functgenomics
	#Or can we findbin this?
	#echo 'Need to validate $SRC here'

	if [ ! -e $funcs_file ]; then
		echo "Could not find $funcsfile"
		echo 'Have you set $SRC correctly in your .bashrc?'
		return
	fi
fi


#Source in some handy functions
. $funcs_file


#Now set some constants dependant on funcs

if [[ ! $(isMac) ]]; then
	export HOSTNAME_SWITCH='-f'
fi


#Source in the efg.config
efg_conf_file=$SRC/ensembl-functgenomics/scripts/environments/efg.config

if [ ! -e $efg_conf_file ]; then
	echo "Could not find $efg_conf_file"
	echo 'Have you set $SRC correctly in your .bashrc?'
	return
fi


. $efg_conf_file


### ENV VARS ###

export ENV_NAME='EFG'

#Prompt
#base colour is blue
export PS1="\
\[\033[34m\]\
${ENV_NAME}:\h>\[\033[0m\]"

### ALIASES ###
#single quotes enable dynamic updating of commands

alias efg='cd $EFG_SRC'
alias efgd='cd $EFG_DATA'
alias efgm='cd $EFG_SRC/modules/Bio/EnsEMBL/Funcgen'
alias efgmacs='xemacs $EFG_SRC/modules/Bio/EnsEMBL/Funcgen &'
alias mysqlw='mysql $MYSQL_ARGS -u${DB_USER}'
alias mysqlro='mysql $MYSQL_ARGS -u${DB_RO_USER}'
alias dasconfdir='cd $EFG_DAS_CONFIG'

#check for vars then suggest defaults or take stdin?


echo "Welcome to eFG!"


### FUNCTIONS ###

EFGHelp(){

	#Take optional opts here to change regex i.e. include all functions

	OPTIND=1

	usage="EFGHelp\n
Description:\tPrints a list of available aliases and functions\n
Usage:\t\tEFGHelp -h(elp)"

	while getopts ":h" opt; do
		case $opt in 
			h  ) echo -e $usage; return 0;;
            \? ) echo -e $usage; return 1;;
        esac 
    done

	echo ''
	echo 'Available aliases:'
	alias | sed 's/^alias //'
	echo ''
	echo 'Available functions:'
	set | grep -E "^[A-Z][a-zA-Z]+[[:space:]]*\(\)[[:space:]]*$" | sort | sed 's/()//'

	echo -e "\nFor more help try: 'FunctionName' -h"

#Can't match end of line here
	#Change all private methods to start with_ so we don't see them here
	#Prefix everything with env name? so we know where they are and can sort?
	#Or maybe just lcfirst everything we don't want to see?


	#'Analysis'Help should print a brief message, point to the docs and then call this method

}

ListDASSources(){
	#Simply list all sets that are DAS_DISPLAYABLE
	#Do we need this or can we simply look at the ini file?
	
	usage="ListDASSources\n
Description:\tLists available DAS sources and their status\n
Usage:\t\tListDASSets [  -D dbname(default=$DB_NAME) -H dbhost(default=$DB_HOST) -U dbuser(default=$DB_RO_USER) -P dbport(default=$DB_PORT) -W dbpassWord(default=$DB_PASS) -a(ll default is only those which are DAS_DISPLAYABLE) -l(ike MYSQL_LIKE_REGEX) -t(ype result|feature|bed) ]"

	all=
	type=
	db_name=$DB_NAME
	db_port=${DB_PORT:=3306}
	db_user=$DB_RO_USER
	db_host=$DB_HOST
	db_pass=$DB_PASS
	db_pass_arg=
	db_port_arg=
	like=
	valid_types='feature result bed'
	OPTIND=1

	while getopts ":at:D:H:U:P:W:l:h" opt; do
		case $opt in 
            a  ) all=1 ;;
            t  ) type=$OPTARG ;;
			D  ) db_name=$OPTARG ;;
            H  ) db_host=$OPTARG ;;
			#Change this to take a list of hosts?
			U  ) db_user=$OPTARG ;;
            P  ) db_port=$OPTARG ;;
			W  ) db_pass=$OPTARG ;;
			l  ) like=$OPTARG ;;
			h  ) echo -e $usage; return 0;;
            \? ) echo -e $usage; return 1;;
        esac 
    done

	valid_types='result feature bed'
	
	if [ $type ]; then
		error=$(ValidateVariableOrUsage "$usage" type valid_types)
	
		if [ $? -ne 0 ]; then
			echo $error
			return 1;
		fi
	fi

	types=${type:=$valid_types}

	error=$(CheckVariablesOrUsage "$usage" db_name db_user db_port db_host)

	if [ $? -ne 0 ]; then
		echo $error
		return 1;
	fi

	#Define mysql optional args
	if [ $db_pass ]; then
		db_pass_arg="-p$db_pass"
	fi

	if [ $db_port ]; then
		db_port_arg="-P$db_port "
	fi


	sql=
	like_clause=
	like_title=

	if [ $like ]; then

		if [ $all ]; then 
			like_clause=" where t.name like \"$like\" "
		else
			like_clause=" and t.name like \"$like\" "		
		fi

		like_title="like '$like'"

	fi
	
	for type in $types; do

		if [[ $type =~ "result|feature" ]]; then

			#We could do a union to get them in the same table


			table="${type}_set"
			title=$(echo $table | tr [a-z] [A-Z])
			echo "$title DAS Sources $like_title"

			#Do we want display_label for feature_sets?
			sql="SELECT t.name as \"Set Name\", \"$type\" as \"Set Type\", sn.name as \"DAS State\", ${table}_id from $table t"
	
			if [ $all ]; then
	
				#Make table alias including only DAS_DISPLAYABLE records to avoid product on left join
				sql="$sql left join (select s.table_id, s.table_name, sn1.name from status s, status_name sn1 where  s.status_name_id=sn1.status_name_id and sn1.name='DAS_DISPLAYABLE') sn  on sn.table_id=t.${table}_id and sn.table_name='$table' $like_clause";
			
			else
				sql="$sql, status s, status_name sn where s.table_id=t.${table}_id and s.table_name=\"$table\" and s.status_name_id=sn.status_name_id and sn.name=\"DAS_DISPLAYABLE\" $like_clause"
			fi

			#echo "mysql -e \"$sql\" -h$db_host -u$db_user $db_pass_arg $db_port_arg $db_name"

			#Don't Execute as we don't want to exit
			mysql -e "$sql" -h$db_host -u$db_user $db_pass_arg $db_port_arg $db_name

		else
			#Deal with bed tables
			#Need to status tables to bed DB schema if not funcgen
			#Then we can set status
			#This should be added to LoadBedDASSources
			sql="show tables like 'bed\_%${like}'"
			echo "BED DAS Sources $like_title"
			
			#echo "mysql -e \"$sql\" -h$db_host -u$db_user $db_pass_arg $db_port_arg $db_name"
	
			mysql -e "$sql" -h$db_host -u$db_user $db_pass_arg $db_port_arg $db_name	
		
		
			#Need to add like here
			
			#Formatting not consistent
			#tables=$(mysql -e "$sql" -h$db_host -u$db_user $db_pass_arg $db_port_arg $db_name)

			#echo "BED DAS Sources"
			#cnt=0

			#for table in $tables; do
				
			#	cnt=$(($cnt+1))

			#	if [[ $cnt -gt 2 ]]; then
			#		echo $table
			#	fi
			#done
		fi
	done
	
}

TurnOnDASSource(){
	usage="TurnOnDASSource\n
Description:\tSets DAS_DISPLAYABLE status for result or feature sets\n
Usage:\t\tListDASSets -t(ype result|feature) -n(ame) [ -i(d only required for non-unique result_set names) -D dbname(default=$DB_NAME) -H dbhost(default=$DB_HOST) -U dbuser(default=$DB_USER) -P dbport(default=$DB_PORT) -W dbpassWord(default=$DB_PASS) ]"


	type=
	off=
	db_name=$DB_NAME
	db_port=${DB_PORT:=3306}
	db_user=$DB_USER
	db_host=$DB_HOST
	db_pass=$DB_PASS
	db_pass_arg=
	db_port_arg=
	valid_types='feature result bed'
	OPTIND=1

	while getopts ":t:n:i:oD:H:U:P:W:h" opt; do
		case $opt in 
            t  ) type=$OPTARG ;;
            n  ) name=$OPTARG ;;
            i  ) id=$OPTARG ;;
			o  ) off=1 ;;
			D  ) db_name=$OPTARG ;;
            H  ) db_host=$OPTARG ;;
			#Change this to take a list of hosts?
			U  ) db_user=$OPTARG ;;
            P  ) db_port=$OPTARG ;;
			W  ) db_pass=$OPTARG ;;
			h  ) echo -e $usage; return 0;;
            \? ) echo -e $usage; return 1;;
        esac 
    done

	valid_types='feature bed'
	#No result yet as we haven't implemented status tables in bed only schema
	

	error=$(ValidateVariableOrUsage "$usage" type valid_types)
	
	if [ $? -ne 0 ]; then
		echo $error
		return 1;
	fi


	error=$(CheckVariablesOrUsage "$usage" type name db_name db_user db_port db_host)

	if [ $? -ne 0 ]; then
		echo $error
		return 1;
	fi

	#Define mysql optional args
	if [ $db_pass ]; then
		db_pass_arg="-p$db_pass"
	fi

	if [ $db_port ]; then
		db_port_arg="-P$db_port "
	fi


	#Grab the DAS_DISPLAYABLE status_name_id first just incase it isn't present?
	#This is in the efg.sql schema, so it should always be there
	
	table="${type}_set"
   
	#We need to handly non-unique result_set names here!
	
	if [ ! $id ]; then

		#Get set_id first to validate
		sql="select ${table}_id from $table where name='$name'"
		ids=($(mysql -e "$sql" -h$db_host -u$db_user $db_pass_arg $db_port_arg $db_name))
	#Should be using QueryVal(needs to sort out clash between pipeline and efg QueryVal) for this?

	#Now test we have only one ids
		no_ids=${#ids[@]}
		
		if [ $no_ids -ne 2 ]; then
			echo "There is more than on $table with the name:\t$name"
			echo "Please specify a table_id"
			id=${ids[1]}
			return 1;
		fi
		
		id=${ids[1]}

	else
		#validate id against name
		sql="select name from $table where ${table_id}='$id'"
		
		tmp=($(mysql -e "$sql" -h$db_host -u$db_user $db_pass_arg $db_port_arg $db_name))

		if [[ ${tmp[1]} != $name ]]; then
			echo "The id($id) and $table name($name) does not match the name in the DB(${tmp[1]}"
		fi
	fi


	if [ $off ]; then
		sql="DELETE s from status s, status_name sn where s.table_id=$id and s.table_name='$table' and s.status_name_id=sn.status_name_id and sn.name='DAS_DISPLAYABLE'"
	else
		sql="INSERT IGNORE into status SELECT '$id', '$table', status_name_id from status_name where name='DAS_DISPLAYABLE'"
	fi

	#echo "mysql -e \"$sql\" -h$db_host -u$db_user $db_pass_arg $db_port_arg $db_name"

	mysql -e "$sql" -h$db_host -u$db_user $db_pass_arg $db_port_arg $db_name

	#Now show that we have turned it on or off

	if [ $db_pass ]; then
		db_pass_arg="-W $db_pass"
	fi

	if [ $db_port ]; then
		db_port_arg="-P $db_port "
	fi

	ListDASSources -t $type -D $db_name -H $db_host -U $db_user $db_pass_arg $db_port_arg -a -l $name
}


TurnOffDASSource(){
	echo "Using TurnOnDASSource with -o(ff) option"
	TurnOnDASSource $* -o
}


LoadBedDASSources(){
	time perl $EFG_SRC/scripts/DAS/load_bed_source.pl $*
	return
	

	#This should also GenerateDASConfig for the given host?
	#Or keep this separate?
	#Need to extend generate_DAS_config.pl to support Das DB
	#i.e. need to parse table_name to generate attrs
	#Or just swwith to hydra for other
	#Hydra will need to have several sources
	#One for each set type per DB
	# i.e. one for the bed DB
	# one for the feature sets in the eFG DB
	# one for the result sets in the eFG DB
	# If the Das BED tables are integrated into the eFG DB
	# How will the adaptor know which tables to use?


	#Need to add -farm flag here? Or always submit to farm?
	#Maybe -no_farm

		#Reset/Declare ind and vars/defaults
	OPTIND=1
	instance=
	das_port=$EFG_DAS_PORT
	das_host=$EFG_DAS_HOST
	das_config=$EFG_DAS_CONFIG
	xsl_home=
	#Default to current working DB details
	species=$SPECIES
	db_name=$DB_NAME
	db_port=${DB_PORT:=3306}
	db_user=$DB_USER
	db_host=$DB_HOST
	db_pass=$DB_PASS
	db_pass_arg=
	db_port_arg=

	files=
	names=
	reads=
	profile=
	bin_size=
	frag_length=
	prefix=
	#Others?
	#no_load
	#profile_input
	
	

	#Getting lots of opts here!
	#Keep DASconfig separate?

	#test $0 here?
	usage='LoadBedDASSources: Loads a DAS source from a BED file as raw alignments or an alignment profile.\n
usage: LoadBedDASSources -i das_instance_name [ -c das_config(default=$EFG_DAS_CONFIG) -p das_port(default=$EFG_DAS_PORT) -s das_host(default=$EFG_DAS_HOST) -D dbname(default=$DB_NAME) -H dbhost(default=$DB_HOST) -U dbuser(default=$DB_USER) -P dbport(default=$DB_PORT) -W dbpassWord(default=$DB_PASS) -S latin_species_name -f feature_set -r result_set -h(elp) -x styleshome ]'

	#We really need to implement getOptArgArray?
	#for -f(iles) -n(ames)

	#Need to add options for individual set config?
	#These could be set as env defaults?
	#We already have some script defaults
	#Not yet implemented in script

	while getopts ":i:p:s:c:D:H:U:P:W:S:f:n:rhab:l:X:NI" opt; do
		case $opt in 
	        i  ) instance=$OPTARG ;; 
            c  ) das_config=$OPTARG ;;
            u  ) das_user=$OPTARG ;;
            p  ) das_port=$OPTARG ;;
            s  ) das_host=$OPTARG ;;
            x  ) xsl_home=$OPTARG ;;
			D  ) db_name=$OPTARG ;;
            H  ) db_host=$OPTARG ;;
			U  ) db_user=$OPTARG ;;
            P  ) db_port=$OPTARG ;;
			W  ) db_pass=$OPTARG ;;
			S  ) species=$OPTARG ;;
            f  ) _setOptArgArray files $* ;; #files=($OptArgArray) ;;
            n  ) _setOptArgArray names $* ;; #names=($OptArgArray) ;;
            r  ) reads=' --reads ' ;;
            a  ) profile=' --profile ' ;;
			b  ) bin_size=" --bin_size $OPTARG ";;
			l  ) frag_length="--frag_length $OPTARG" ;;
			X  ) prefix="--prefix =$OPTARG" ;;
			N  ) no_load='--no_load' ;;
			I  ) profile_input='--profile_input' ;;
            h  ) echo -e $usage; return 0;;
            \? ) echo -e $usage; exit 1;;
        esac 
    done



	#Shall we also check other vars here so that the env doesn't exit?

	error=$(CheckVariablesOrUsage "$usage" instance das_port das_host das_config db_name db_user db_port db_host EFG_DAS_HOME files)

	#Let script handle this?
	#if ( ! ([ $reads ] || [  $profile ])); then
	#	echo 'You must supl

		#Is this catching correctly?
	if [ $? -ne 0 ]; then
		echo $error
		return 1;
	fi



	#Define for script
	if [ $db_pass ]; then
		db_pass_arg="--dbpass $db_pass"
	fi

	if [ $db_port ]; then
		db_port_arg="--db_port $db_port "
	fi

	#Now run load script
	perl $EFG_SRC/scripts/DAS/load_bed_source.pl \
		--host $db_host\
		--user $db_user\
		--dbname $db_name\
		$db_port_arg\
		$db_pass_arg\
		--files ${files[*]}\
		--names ${names[*]}\
		$prefix\
		$reads\
		$profile\
		$no_profile\
		$bin_size\
		$frag_length\
		$profile_input



	#Just return if the load failed
	if [ $? -ne 0 ]; then
		return 1
	fi



	#now redefine for GenerateDASConfig opt
	if [ $db_pass ]; then
		db_pass_arg="-W $db_pass"
	fi

	if [ $db_port ]; then
		db_port_arg="-P $db_port "
	fi

	if [ ! $xsl_home ]; then
		xsl_home=" -x ${EFG_DAS_HOME}/stylesheets "	
	else
		xsl_home=" -x $xsl_home "
	fi	

	#Or should we do this separately?
	#We don't need to do this after loading a hydra source!!
	#GenerateDasConfig 


}

GenerateDASConfig(){

	
	#Need to add dasdb stuff here for the Bed sources?
	#Or do we need a flag for using bed/profile DB?
	#Just switch to hydra
	#Is result_feature display working yet?
	
	#Need to add options to set hydra config
	#for each type e.g. all bed tables, displayable feature/resultsets

	#Do we now need to separate out code to set dispayable states?
	#As we may not need to regenerate conf unless we have added a source type
	#MakeSetDASDisplayable
	#This would require ListDASSets -result_sets -feature_sets -bed_sets

	#Separate tables prevents data in normal table from being displayed using same code
	#Can we not just use the same table?
	#Here we hit partitioning problem?
	#We never load just reads into DB normally
	#Just implement as is for now

	#echo "This method has been deprecated. Please use $EFG_SRC/scripts/DAS/generate_DAS_config.pl (-h for help)"

	perl $EFG_SRC/scripts/DAS/generate_DAS_config.pl $*

	return

	#Reset/Declare ind and vars/defaults
	OPTIND=1
	instance=
	das_port=$EFG_DAS_PORT
	das_host=$EFG_DAS_HOST
	das_config=$EFG_DAS_CONFIG
	feature_set=
	result_set=
	xsl_home=
	#Default to current working DB details
	species=$SPECIES
	db_name=$DB_NAME
	db_port=${DB_PORT:=3306}
	db_user=$DB_USER
	db_host=$DB_HOST
	db_pass=$DB_PASS

	#Hydra stuff
	not_hydra=
	#default all types, adaptor will pick out displayable
	source_types='feature_set result_set bed'
	

	
	usage='usage: GenerateDASConfig -i das_instance_name [ -c das_config(default=$EFG_DAS_CONFIG) -p das_port(default=$EFG_DAS_PORT) -s das_host(default=$EFG_DAS_HOST) -D dbname(default=$DB_NAME) -H dbhost(default=$DB_HOST) -U dbuser(default=$DB_USER) -P dbport(default=$DB_PORT) -W dbpassWord(default=$DB_PASS) -S latin_species_name -f feature_set -r result_set -x styleshome -n(not_hydra)-t sourceTypes(default=(feature_set result_set bed) -h(elp) ]'


	#Need to add options for individual set config?
	#These could be set as env defaults?
	#We already have some script defaults
	#Not yet implemented in script


	#Need to add severroot, maintainer

	while getopts ":i:p:s:c:D:H:U:P:W:S:f:r:h" opt; do
		case $opt in 
	        i  ) instance=$OPTARG ;; 
            c  ) das_config=$OPTARG ;;
            u  ) das_user=$OPTARG ;;
            p  ) das_port=$OPTARG ;;
            s  ) das_host=$OPTARG ;;
            x  ) xsl_home=$OPTARG ;;
			D  ) db_name=$OPTARG ;;
            H  ) db_host=$OPTARG ;;
			U  ) db_user=$OPTARG ;;
            P  ) db_port=$OPTARG ;;
			W  ) db_pass=' --dbpass $OPTARG ';;
			S  ) species=$OPTARG ;;
			f  ) feature_set=$OPTARG ;;
            r  ) result_set=$OPTARG ;;	
			n  ) not_hydra=' --not_hydra ' ;;
			t  ) _setOptArgArray source_types $* ;;  #Should this be $@ to avoid spliting 'words with' with spaces?
            h  ) echo $usage; return 0;;
            \? ) echo $usage; exit 1;;
        esac 
    done

	#There is no way we can set the display names for each individual set
	#Should we allow group config?
	#This would require modifying display_names directly in the ini file?
	#f  ) feature_sets='$OPTARG $feature_sets' ;;
    #        r  ) result_sets='$OPTARG $result_sets' ;;

    #Can we use $MYSQL_SCRIPT_ARGS here?

	error=$(CheckVariablesOrUsage "$usage" instance das_port das_host das_config db_name db_user db_port db_host EFG_DAS_HOME)

	if [ ! $xsl_home ]; then
		xsl_home=" -styleshome ${EFG_DAS_HOME}/stylesheets "
	else
		error='-x styleshome parameter cannot be found' 
		error=$(CheckFilesOrUsage "$error" xsl_home)
	
	 	if [ $? -ne 0 ]; then
 			echo $error;
			return 1
		fi

		xsl_home=" -styleshome $xsl_home "
	fi

	#Is this catching correctly?

	if [ $? -ne 0 ]; then
		echo $error
		return 1;
	fi


	#We should just let the script handle all the parameter checking here!
	#Need to check params as we don't want a misleading hepl message from the script?
	#Can we just drop this func and use the script with env var defaults?


	if [ $result_set ] && [ $feature_set ]; then
		echo 'Cannot specifiy both -r(esult_set) and -f(eature_set). Can only add/custom configure one set at a set'
		return 1;
	fi

	set_string=

	if [ $result_set ]; then
		set_string=" -set_type result -set_name $result_set "
	elif [ $feature_set ]; then
		set_string=" -set_type feature -set_name $result_set "
	fi

	if [ $source_types ]; then
		source_types=" --source_types ${source_types[*]}"
	fi
	
	perl $EFG_SRC/scripts/DAS/generate_DAS_config.pl \
		-species $species\
		-dbport $db_port\
		-dbhost $db_host\
		-dbuser $db_user\
		-dbname $db_name\
		$db_pass\
		$xsl_home \
		$not_hydra\
		$source_types\
		-das_host $das_host\
		-das_port $das_port\
		-das_config $das_config\
		-das_name $instance

}


StartDASServer(){
	#This needs to cat config/html files for a given DAS instance
	#And restart/start the server as necessary
	
	#Reset/Declare ind and vars/defaults
	OPTIND=1
	instance=
	das_port=$EFG_DAS_PORT
	das_host=$EFG_DAS_HOST
	das_config=$EFG_DAS_CONFIG
	no_fork=
	debug=
	usage='usage: StartDASServer -i das_instance_name [ -c das_config(default=$EFG_DAS_CONFIG) -p das_port(default=$EFG_DAS_PORT) -s das_host(default=$EFG_DAS_HOST) -x(no fork) -h(elp) -d(ebug) ]'

	while getopts ":i:c:p:s:xdh" opt; do
		case $opt in 
	        i  ) instance=$OPTARG ;; 
            c  ) das_config=$OPTARG ;;
            p  ) das_port=$OPTARG ;;
            s  ) das_host=$OPTARG ;;
            x  ) no_fork=' -x ' ;;
            d  ) debug=' -debug ' ;;
h  ) echo $usage; return 0;;
\? ) echo $usage; exit 1;;
        esac 
    done

#		d  ) das_home=$OPTARG ;;


	#This isn't working if we don't set -i???
	$(CheckVariablesOrUsage "$usage" instance das_port das_host das_config EFG_DAS_HOME)


	if [ $? -ne 0 ]; then
		echo $error
		return 1;
	fi


	#Validate EFG_DAS_HOME here i.e. check it is a ProServer?


    #CheckHost 	
	#-f is not valid for Darwin
	#
	fq_domain_name=$(hostname -f)



	if [ $das_host != $fq_domain_name ]; then
		echo "You must run this from the DAS host($das_host). You are currently logged into $fq_domain_name"
		return 1
	fi

	#Do we need to validate this against the header file?
	#We could have individual directories for each db
	#and individual files for each source?
	#This way we could easily add and remove individual sources
	
	#Currently we can't restart the server using this func as the input files are deleted

	#Cannot use : in instance name here as Bio::Das::Proserver::Config truncates!
	instance_name=${instance}.${das_host}.${das_port}	
	config_header=${das_config}/${instance_name}.config.header
	html_header=${das_config}/${instance_name}.html.header
	error='Maybe you need to GenerateDASConfig?'
	
	#Subshell this so we just return instead of exiting the env
	error=$(CheckFilesOrUsage "$error" config_header html_header)
	
	if [ $? -ne 0 ]; then
		echo $error;
		return 1;
	fi


	#Now list files using patterns based on instance name

	#+ does not work here? how did it ever?

	#Pipe this through grep to make sure we only get file matchign regex rather than imprecise glob

	config_files=$(ls ${das_config}/${instance}.*.sources | grep -E "${das_config}/${instance}\..+\.[0-9]+\..*\.[a-zA-Z]+\.sources")
	html_files=$(ls ${das_config}/${instance}.*.html | grep -E "${das_config}/${instance}\..+\.[0-9]+\..*\.[a-zA-Z]+\.html")

	
	for list in "$html_files" "$config_files"; do
 
		if [[ $list = "*No such file*" ]]; then
			echo $list
			return 1
		fi
	done


	#Stop the server
	#Before we start messing aroung with the config
	StopDASServer -i $instance -c $das_config -p $das_port -s $das_host


	#Now check there isn't another process listening on the port
	running_process=$(netstat -an | grep -E ':$das_port[[:space:]]' | grep -i listen)
	#could add -p here to get pid/name but need to be root
	
	if [ $running_process ]; then
		echo "There is already a process listening on port $das_port"
		echo $running_process
		return 1;
	fi


	#Cat the config files
	config_file=${das_config}/${instance_name}.ini
	BackUpFile $config_file
	cat $config_header $config_files > $config_file
	#rm -f $config_header $config_files
	
	#Cat the html files
	html_file=${das_config}/${instance_name}.html
	BackUpFile $html_file
	cat $html_header $html_files > $html_file
	#rm -f $html_header $html_files
	#Now add the footer
	echo '</body></html>' | cat >> $html_file

	#Start the server
	echo "Starting DAS server with:"
	echo "$EFG_DAS_HOME/eg/proserver $no_fork $debug -c $config_file"

	$EFG_DAS_HOME/eg/proserver $no_fork $debug -c $config_file
	
	if [ $? -ne 0 ]; then
		echo "Failed to start DAS instance: $instance_name"
		return 1
	elif [ ! $no_fork ]; then
		echo "Started DAS instance: $instance_name"
	fi

}


StopDASServer(){
	echo ":: StopDASServer $*"
	#This makes sure we reset the getopts ind if we have used it previously
	OPTIND=1

	instance=
	das_config=
	das_port=
	das_host=
	usage='usage: StopDASServer -i das_instance_name [ -c das_config(default=$EFG_DAS_CONFIG) -p das_port(default=$EFG_DAS_PORT) -s das_host(default=$EFG_DAS_HOST) -h(elp) ]'


	#Can we take array_names here too
	#Is this wise to restrict to arrays within a linked set


	while getopts ":i:p:s:c:h" opt; do
		case $opt in 
	        i  ) instance=$OPTARG ;; 
            p  ) das_port=$OPTARG ;;
            s  ) das_host=$OPTARG ;;
			c  ) das_config=$OPTARG ;; 
h  ) echo $usage; return 0;;
\? ) echo $usage; exit 1;;
        esac 
    done


	das_port=${das_port:=$EFG_DAS_PORT}
	das_host=${das_host:=$EFG_DAS_HOST}
	das_config=${das_config:=$EFG_DAS_CONFIG}


	error=$(CheckVariablesOrUsage "$usage" instance das_port das_host das_config)

	if [ $? -ne 0 ]; then
		echo $error;
		return 1;
	fi

	
    #CheckHost 	
	fq_domain_name=$(hostname -f)

	if [ $das_host != $fq_domain_name ]; then
		echo "You must run this from the DAS host($das_host). You are currently logged into $fq_domain_name"
		return 1
	fi


	instance_name=${instance}.${das_host}.${das_port}

	#Stop the server
	pid_file=${das_config}/${instance_name}.pid

	if [ -f $pid_file ]; then
		pid=$(cat $pid_file)
		ps $pid

		if [ $? -eq 0 ]; then
			kill -TERM $pid

			if [ $? -ne 0 ]; then
				echo "Failed to stop DAS instance($pid): $instance_name"
				return 1
			else
				echo "Stopped DAS instance: $instance_name"
			fi

		else
			echo "$instance_name DAS instance($pid) is not running"
		fi
	else
		echo "Could not find proserver pid file: $pid_file"
	fi
}




CreateDB(){

	#This makes sure we reset the getopts ind if we have used it previously
	OPTIND=1

	drop=
	skip=
	species=
	pass=
	dbname=
	usage='usage: CreateDB -d dbname -p password -s(pecies) e.g. e.g homo_sapiens [ -f(orce drop database) -t(skip type import)]'


	#Can we take array_names here too?
	#Is this wise to restrict to arrays within a linked set?


	#Do we need to add dnadb params here?
	#And maybe override args for other db params
	#or should we provide a UseHost function?

	while getopts ":d:p:hfs:t" opt; do
		case $opt in 
	        d  ) dbname=$OPTARG ;; 
	p  ) pass=$OPTARG ;;
	f  ) drop=1 ;;
	t  ) skip=1 ;;
    s  ) species=$OPTARG ;;
	h  ) echo $usage; return 0;;
	\? ) echo $usage; exit 1;;
	esac 
	done

	error=$(CheckVariablesOrUsage "$usage" dbname pass)

	
	if [ $? -ne 0 ]; then
		echo -e $error;
		return 1;
	fi


	#We should do some validation of the dbname here


    present=$(_QueryVal show databases like \"$dbname\")
     
    if [[ $present ]]
    then

        if [[ $drop ]]
        then
            echo "Dropping DB $dbname"
			#Need to Execute this
			mysqlw -p${pass} -e "DROP DATABASE IF EXISTS $dbname"
        else
            echo "DB $dbname already exists, please drop the database manually specify -f(orce) to drop the DB'"
            return
        fi
    fi

    echo "Creating DB $dbname"
    echo "CREATE database $dbname" | mysqlw -p${pass}
    mysqlw -p${pass} $dbname < $EFG_SQL/efg.sql


	#Now insert schema_version into meta to avoid warnings
	#Should really validate dbname first
	
	schema_version=$(echo $dbname | sed 's/_/ /g')
	#Turn space separated string into array
	schema_version=($schema_version)
	schema_posn=${#schema_version[*]}
		
	schema_posn=$(( $schema_posn - 2 ))	
	schema_version=${schema_version[$schema_posn]}
	
	if [[ ! $schema_version =~ ^[[:digit:]]+$ ]]; then
		echo "WARNING: Could not identify a valid schema_version($schema_version) from your dbname: $dbname"
		echo "Please rename your db as follows: any_prefix_latin_species_funcgen_SCHEMA_BUILDn e.g. my_homo_sapiens_funcgen_54_36p"
		return 1;
	fi

	mysqlw -p${pass} -e "INSERT into meta(meta_key,meta_value) values('schema_version', '$schema_version')" $dbname


	#Now import the standard Cell/FeatureTypes
	if [ ! $skip ]; then

		error=$(CheckVariablesOrUsage "$usage" species)

		if [ $? -ne 0 ]; then
			echo $error;
			return 1;
		fi

		perl $EFG_SRC/scripts/import/import_type.pl $DNADB_SCRIPT_ARGS -host $DB_HOST -dbname $dbname -species $species -pass $pass -type Analysis -file $EFG_SRC/scripts/import/types/Analyses.txt
		
		perl $EFG_SRC/scripts/import/import_type.pl $DNADB_SCRIPT_ARGS -host $DB_HOST -dbname $dbname -species $species -pass $pass -type FeatureType -file $EFG_SRC/scripts/import/types/FeatureTypes.txt

		cell_types_file=$EFG_SRC/scripts/import/types/${species}.CellTypes.txt
		#Not present for all species

		if [ -e $cell_types_file ]; then

			perl $EFG_SRC/scripts/import/import_type.pl $DNADB_SCRIPT_ARGS -host $DB_HOST -dbname $dbname -species $species -pass $pass -t CellType -file $EFG_SRC/scripts/import/types/${species}.CellTypes.txt
		else
			echo "WARNING: Could not file CellType file: $cell_types_file"
			echo "Either generate this file and re-run CreateDB or use import_type.pl"
		fi


	fi

	echo "Created $dbname"
	
}

CreateLocalDB(){
	TMP=$MYSQL_ARGS
	MYSQL_ARGS=" -P${DB_PORT}";
	CreateDB $@
	export MYSQL_ARGS=$TMP


}


#This clashes with pipeline.env QueryVal
#and breaks CreateDB due to mysqlro and MYSQLARGS

_QueryVal(){

    #need to check if PASS defined else use READ_NAME
    val=$(echo $* | mysqlro)

	#should capture error here
	#this works differently if passing a var or passing a quoted string, var get's split
	#do not quote query!
	echo $val | sed "s/$2 //"
}



RunUsage(){
	#do run usage first then run the parse_and_import.pl script

	echo "Usage: run.sh 'password' [result files]"
	echo "       ARG[0]: 'password' - the write password to the import db specified in run.sh"
	echo "       ARG[@]: optional - list of result files to use during import, currently only works for Sanger import"

}

#This can be moved to funcs.sh ?

UseBranch(){
	branch=$1

	if [[ ! $branch ]]
    then
		echo "Need to define and API version to create softlinks for"
		echo "UseBranch 50"
	return
    fi 


	#Should really test for softlinks here to avoid deleting a directory

	modules=('ensembl ensembl-functgenomics')

	cdir=$PWD

	cd $SRC

	for module in $modules
	do
		if [ -e $module ]
		then

  			if [ -L $module ]
			then
				rm -f $module		
			else
				echo "Failed: Module $module is not a symbolic link, please rectify by moving to vBRANCH dir"
				return
			fi
		fi
	
		if [ -d v$branch/$module ]
	  	then
	   		ln -s v$branch/$module $module
	   	else
	   		#could do cvs check out here
	   		echo "You have not yet checked out v$branch/$module"
	   		return
	   	fi
	done

	echo "Now using v$branch for modules: $modules"

	cd $cdir

}


GetRegulatoryAttributeSets(){
	
	#echo ":: GetRegulatoryAttributeSets $*"
	#This makes sure we reset the getopts ind if we have used it previously
	OPTIND=1

	user=$DB_USER
	dbname=$DB_NAME
	host=$DB_HOST
	port=$DB_PORT
	pass=$PASS
	field=name
	version=
	usage='usage: GetRegulatoryAttributeSets -u(ser $DB_USER) -h(ost $DB_HOST) -d(bname $DB_NAME) [ -p(assword $PASS) -P(ort $DB_PORT) -f(ield name) -v(ersion e.g 4 default is current) -h(elp) ]'


	while getopts ":u:d:H:p:P:v:f:h" opt; do
		case $opt in 
	        u  ) user=$OPTARG ;; 
            d  ) dbname=$OPTARG ;;
            H  ) host=$OPTARG ;;
			P  ) port=$OPTARG ;; 
			p  ) pass=$OPTARG ;;
			f  ) field=$OPTARG ;;
			v  ) version=$OPTARG ;;
			h  ) echo $usage; return 0;;
			\? ) echo $usage; exit 1;;#Do we want exit here?
        esac 
    done

		
	CheckVariables user dbname host

	#Set some more defaults
	port=${port:=3306}
	
	if [ $pass ]; then 
		pass="-p${PASS}"
	fi

	if [ $version ]; then
		version="_v${version}"
	fi

	if [[ $field != '*' ]]; then
		field="$field as '' "
	fi
	
	sql="select fs.${field} from data_set ds, supporting_set ss, feature_set fs where ds.name='RegulatoryFeatures${version}' and ds.data_set_id=ss.data_set_id and ss.supporting_set_id=.fs.feature_set_id order by fs.name";

	#Can we QueryVal this?

	#we need to strip the header if field is not *
	
	

	mysql -e "$sql" -h$host -u$user $pass -P$port $dbname | sed '/^$/d'


}






#Should we add QC methods here or keep these in the sql/perl script?
#Maybe we can source these in as different function module?
#Or is this better kept in perl but separate from API methods?
