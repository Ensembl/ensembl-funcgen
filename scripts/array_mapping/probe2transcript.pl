#!/usr/bin/env perl

=head1 LICENSE

Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
Copyright [2016] EMBL-European Bioinformatics Institute

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

=head1 CONTACT

Please email comments or questions to the public Ensembl
developers list at <http://lists.ensembl.org/mailman/listinfo/dev>.

Questions may also be sent to the Ensembl help desk at
<http://www.ensembl.org/Help/Contact>.

=head1 NAME

probe2transcript.pl

=head1 SYNOPSIS

This script performs probe(set) to transcript mapping based on a few simple parameters. Overlap analysis
of ProbeFeatures is performed and annotations are stored as xrefs for individual ProbeFeatures, Probes or
ProbeSets as a whole. Any probe(set)s which fail the mapping procedure are by default stored in the
UnmappedObject tables and a logfile is also written.

e.g. perl probe2transcript.pl --species $SPECIES --transcript_dbname $DNADB_NAME --transcript_host $DNADB_HOST --transcript_port $DNADB_PORT --transcript_user $DNADB_USER --xref_host $DB_HOST --xref_dbname $DB_NAME --xref_user $DB_USER --xref_pass $DB_PASS --calculate_utrs --utr_multiplier 1 --arrays HT_MG-430A  -vendor AFFY -format AFFY_UTR


=head1 DESCRIPTION

More wordy description here

promiscuous probes
completed unmapped probes
linked arrays

This is generally executed by the eFG array mapping environment

=head1 OPTIONS

Mandatory
-species    Latin name as used in DB name or meta table e.g. homo_sapiens
-vendor     Array vendor e.g. AFFY, ILLUMINA etc
-format     Array format e.g. AFFY_UTR, AFFY_ST, ILLUMINA_WG. Sets default array configuration
-arrays     List (space separated) of array names.

Array configuration:
-linked_arrays       Boolean(0|1) - For probe(set)s which exist on multiple array e.g. AFFY
-probeset_arrays     Boolean(0|1) - For arrays which contain probesets rather than just single probes
-sense_interrogation Boolean(0|1) - Sets interrogation strand, normally 1 for AFFY but 0 for AFFY_ST i.e. anti-sense

Mapping rules:

-mismatches                  Maximum number of mismatches allowed per probe
-calculate_utrs              This calculates the default unannotated UTR extension defined by
the greater of either the mean or the median of all annotated UTRs
This is overridden by the following extend options
-unannotated_5_utr           Default extension for transcripts with unannotated 5' UTRs
-unannotated_3_utr           Default extension for transcripts with unannotated 3' UTRs
-annotated_5_prime_extend    Default bp extension for all transcripts with annotated 5' UTRs
-annotated_3_prime_extend    Default bp extension for all transcripts with annotated 3' UTRs
-utr_multiplier              Defines UTR extension as multiple of annotated UTR. This is overridden
if the above options are set.
-max_transcripts             Maximum number of transcripts probe(set) can map to before we call it
promiscuous, default is 100.
-threshold                   This is the fraction(0-1) of probes within a probeset required to call it
mapped, default is 0.5


Running modes:

-delete           Delete all pre-existing array xrefs generated by probe2transcript for given arrays
-no_triage        Does not load UnmappedObjects (still writes to log file)
-parallelise      Not yet implemented, will chunk and submit to farm
-clean_up         Not yet implemented, will perform post parallelised run clean up

DB connection parameters, registry will override direct connection:

-reg_verbose    Turns on verbose output when loading the registry

-reg_host
-reg_port
-reg_user
-reg_pass

or

-reg_file

or

-transcript_host          Mandatory
-transcript_user          Mandatory
-transcript_port
-transcript_pass          Mandatory
-transcript_dbname        Mandatory
-transcript_multi_species
-transcript_species_id

-xref_host          Mandatory
-xref_user          Mandatory
-xref_port
-xref_pass          Mandatory
-xref_dbname        Mandatory
-xref_multi_species
-xref_species_id

-probe_host           Probe parameters
-probe_user           default to xref
-probe_port           DB paramters
-probe_pass           if not
-probe_dbname         specified
-probe_multi_species
-probe_species_id

Testing:

-test_transcripts   Number of transcripts to perform a test run on.
-slice              Name of test slice to perform a test run on
-transcript         Test transcript stable ID
-no_store           Not yet implemented

Other options:
-import_edb         Automatically imports the external_db record if not present
-tee                Tees output to STDOUT
-filename           Sets name to be used in output and logfile, default is xref_dbname_probe2transcript.log|out
-help               Prints this POD documentation and exits


=head1 EXAMPLE


=head1 SEE ALSO

ensembl-funcgen/scripts/environments/arrays.env

=cut

#To do

# 1. Reimpliment validate arrays, see old script?
# 2. Add unannotated UTR clipping dependant on nearest neighbour
# 3. Extend UTRs to default length is they are less than defaults, so long as they don't overlap neighbour,
#    then use annotated if present or clip to neighbour start/end if not, also accounting for default UTRs
#    in the neighbour.
# 4. Separate UTR multipliers for 3' and 5'?
# 5. Implement incremental update from list of stable IDs. Consider unmapped probe changes etc.
# 6. Parallelise by probeset chunks, can't do this by chromosome slices as we need to know genomewide
#    counts for a given probeset. Calc UTRs then submit chunks jobs to farm
#    Chunk by retrieving all probesets and sorting an array of probeset names, then splice the array
#    according to the number of chunks. We're still going to have retrieve all the transcripts and retrieve
#    all probes for each, so we are really not gaining anything!! The only gain we can make is by chunking
#    by slice, but then we need to know how many times something has mapped. Can we do some clean up afterwards?
#    Let's add a clean up mode which simply deletes all probe sets which map too many times. We would need to
#    ignore this threshold as we were mapping!!! So we don't delete and then mess up the counts for post run
#    clean up.
# 7. There is no reason to have separate probe and xref DBs???
# 8. Validate array format against arrays specified? May want to just use an array format as a template???
# 9. Add mismatch filter for ProbeTranscriptAlign xrefs as match rules can differ between alignment and
#    annotation
# 10.Handle ProbeAlign mismatch vs overlap mis match. Currently the overlap calculation is naive to the
#    presence of alignment mis-matches.  Which means there is a possiblity of including probes with a total
#    sequence mismatch of (align mismatch + overlap mismatch). This has always been the case.
# 11.Move ProbeAlign unmapped object storage to write_output, then this will not get written in test mode and
#    we won't get duplication should the job fail halfway through. This is because hceck existing only check oxs, not uos.
# 12.Enable probesets to have different sizes on different arrays, see notes in cache_arrays_per_object
# 13.Collect warning into summary repoprt to list at very end.
# 14 Reduce max_transcripts as this is never being hit due to alignment threshold
# 15 Why can't we omit -arrays if we have -format?
# 16 Add UTR only overlap  in range registry.
# 17 Check for ProbeFeature xrefs and UOs in check_existing_and_exit?
# 18 PostAlign/PreXref processing
#    Remove duplicated ProbeFeatures(from ProbeTranscriptAlign) and redirect Xrefs
#    Being careful to make sure cigarlines are valid for both.
#    Remove ProbeTranscriptAlign ProbeFeaturess which have been called promiscuous
#    by ProbeAlign, and update to promiscuous if sum of ProbeAlign and
#    ProbeTranscriptAlign features render a Probe promiscuous

#Ensembl Genomes stuff
# TEST Registry usage required as species will come from same DB
# In which case we need to take a species param for each of the transcript, array and xref DBs
# Or can we force delete to be species specific? We would need to do this anyway to support updating of species asynchronously
# We probably need to think about this for the 1st stage too,
# but will be easy as we just need to dump the correct top level sequence
# Validate species against registry alias and use this to generate species_core_Gene DB rather than ensembl_core_Gene
# patch other efg DBs and alter External parsers accordingly.
# Can't rely on Registry as species aliases may not be present or loaded

# Issues
# Cannot account for running non-linked arrays which may use the same probe/set name.  This may cause failure if the probeset sizes are different. Xrefs and counts should be unaffected as we base these on the probe_set_ids not the names. This is not really an issue as unlinked arrays should not be run together
# Cannot currently handle probesets with different sizes between arrays, defaults to lowest probeset size to be permissive. See todo 12.

use strict;
use warnings;
use locale; # Needed to ensure consistent ordering between Perl and UNIX sort

use Pod::Usage;
use Getopt::Long;
use File::Temp qw/tempfile/;
use DBI qw(:sql_types);
use Carp qw( croak );

use Bio::EnsEMBL::DBEntry;
use Bio::EnsEMBL::UnmappedObject;
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Mapper::RangeRegistry;
use Bio::EnsEMBL::Registry;
use Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Funcgen::Utils::Helper;
use Bio::EnsEMBL::Funcgen::Utils::EFGUtils qw (median mean get_date);

#Helper params
$main::_log_file = undef;
$main::_tee      = 0;
local $| = 1; # auto flush stdout
our $Helper = Bio::EnsEMBL::Funcgen::Utils::Helper->new();
my $debug = 0;

#Array format config for current vendors
my %array_format_config =
(
  AFFY_UTR => {
    probeset_arrays         => 1,
    linked_arrays      => 0,
    sense_interrogation  => 0,

  },

  AFFY_ST => {
    probeset_arrays         => 1,
    linked_arrays      => 1,
    sense_interrogation  => 1,
  },

  ILLUMINA_WG => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },

  AGILENT => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },


  PHALANX => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },

  CODELINK => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },

  LEIDEN => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },

  STEMPLE_LAB_SANGER => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },
  NIMBLEGEN_MODENCODE => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },
  SLRI => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },
  UCSF => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },

  WUSTL =>  {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },
);

=head2 main

  Description: Where everything is

=cut

main();

sub rollback_arrays {

  my $options = shift;

  my $rollback_array_script = 'rollback_array.pl';

  my $full_path = `which $rollback_array_script`;

  if (! $full_path) {
    die ("Can't find the rollback script in the path. It is in the scripts/rollback/ subdirectory of the ensembl-funcgen checkout. Please consider adding this to you PATH environment variable.");
  }

  my $arrays = join " ", @{$options->{array_names}};
  
  my $cmd = 'rollback_array.pl'

  . ' --species '     . $options->{species}
  . ' -dbhost '       . $options->{xref_host}
  . ' -dbname '       . $options->{xref_dbname}
  . ' -dbuser '       . $options->{xref_user}
  . ($options->{xref_port} ? ' -dbport '       . $options->{xref_port} : '')
  . ($options->{xref_pass} ? ' -dbpass '       . $options->{xref_pass} : '')

  . ($options->{transcript_pass} ? ' -dnadb_pass '   . $options->{transcript_pass}: "")
  . ($options->{transcript_port} ? ' -dnadb_port '   . $options->{transcript_port}: "")
  . ' -dnadb_name '   . $options->{transcript_dbname}
  . ' -dnadb_host '   . $options->{transcript_host}
  . ' -dnadb_user '   . $options->{transcript_user}

  . ( $options->{xref_pass}       ? ' -dbpass '     . $options->{xref_pass}       : '' )
  . ( $options->{transcript_pass} ? ' -dnadb_pass ' . $options->{transcript_pass} : '' )

  . ' -arrays '.$arrays.' -m probe2transcript ';

    print "\ncmd = $cmd\n";

    run($cmd);
}

sub main {
  my $options = get_options();

  $Helper->log('Setting global constant variables', 0, 'append_date');
  my ($probe_db, $transcript_db, $xref_db) = @{get_databases($options)};

  $Helper->log("Rolling back results from previous runs of this type", 0, 'append_date');
  rollback_arrays($options);
  $Helper->log("Done with rollbacks.", 0, 'append_date');

  $options->{arrays} = get_arrays($xref_db, $options->{vendor}, $options->{array_names});
  my $schema_build = $xref_db->_get_schema_build($transcript_db);
  my $transc_edb_name = "$options->{species}_core_Transcript";
  
#   $options->{transc_edb_id} = get_external_db_id($xref_db, $options->{species}, $transc_edb_name, $schema_build, $options->{import_edb});
  
  $options->{analysis} = get_or_create_analysis($xref_db);
  my $transcripts = get_transcripts($transcript_db, $options->{test_slice}, $options->{test_transcript_sid});
  $options->{rr} = Bio::EnsEMBL::Mapper::RangeRegistry->new();
  $options->{unmapped_object_adaptor} = $xref_db->get_UnmappedObjectAdaptor();
#   $options->{transcript_xref_id} = get_transcript_xref_ids($xref_db, $options->{transc_edb_id});
  # DEBUG: Naughty hidden global
  $options->{desc_to_id} = {};

#   check_xrefs($xref_db, $options->{transc_edb_id}, $transcripts, $options->{transcript_xref_id});
#   $Helper->log('Cleaning xrefs to avoid duplicate entries', 0, 'append_date');
#   if($options->{delete}) {
#     my $array_names = '"'.join('", "', @{$options->{array_names}}).'"';
#     my $text = "Deleting $options->{species}" . ($array_names) ? "($array_names)" : 'ALL';
#     $Helper->log("$text unmapped records and xrefs for probe2transcript...this may take a while");
#     delete_existing_xrefs($options->{array_names});
#   } else{
#     $Helper->log_header('Checking existing Xrefs');
#     check_existing_and_exit($xref_db, $transc_edb_name, $options);
#   }
#   $Helper->log('Checking that all probes link to analyses', 0, 'append_date');
#   check_probe_analysis_join($probe_db);
  $Helper->log("Caching arrays per $options->{xref_object}", 0, 'append_date');
  ($options->{arrays_per_object}, $options->{probeset_sizes}, $options->{object_names}) = @{cache_arrays_per_object($probe_db, $options)};
  $Helper->log('Caching transcript / probe feature xrefs', 0, 'append_date');
  
  # This ($options->{transcripts_per_probefeature}) is later used by 
  # "sub record_gapped_probefeature" and gets covertly passed in via the 
  # $options hashref.
  #
  $options->{transcripts_per_probefeature} = get_transcripts_per_probefeature($xref_db, $options, $Helper);
  if($options->{calc_utrs}) {
    $Helper->log('Calculating default UTR lengths from greatest of max median|mean', 0, 'append_date');
    calculate_utrs($options->{unannotated_utrs}, $transcripts);
    $Helper->log('Finished calculating unannotated UTR lengths', 0, 'append_date');
  }

  $Helper->log('Writing extended transcript slices into Bed file', 0, 'append_date');
  my ($fh, $filename) = tempfile(DIR => $options->{temp_dir});
  write_extended_transcripts_into_file($transcripts, $filename, $options);

  $Helper->log('Dumping probes into Bed file', 0, 'append_date');
  my ($fh2, $filename2) = tempfile(DIR => $options->{temp_dir});
  dump_probe_features($filename2, $options);

  $Helper->log('Overlapping probe features and transcripts', 0, 'append_date');
  my ($fh3, $filename3) = tempfile(DIR => $options->{temp_dir});
  run("bedtools intersect -sorted -wa -wb -a $filename -b $filename2 | sort -k4,4 > $filename3");
  close $fh;
  unlink $filename;
  close $fh2;
  unlink $filename2;

# Pesky global variables
  my $xrefs = [];
  my $unmapped_objects = [];
  my $unmapped_counts = {};

  $Helper->log('Performing overlap analysis.', 0, 'append_date');
  my $object_transcript_hits = associate_probes_to_transcripts($transcripts, $fh3, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $Helper);
  unlink $filename3;

  $Helper->log('Logging probesets that don\'t map to any transcripts', 0, 'append_date');
  log_unmapped_objects($object_transcript_hits, $unmapped_counts, $unmapped_objects, $options, $Helper);
  $Helper->log('Filtering out promiscuous objects', 0 , 'append_date');
  remove_promiscuous_objects($object_transcript_hits, $unmapped_counts, $unmapped_objects, $options, $Helper);
  $Helper->log('Flushing last unmapped probesets', 0 , 'append_date');
  if(scalar @$unmapped_objects) {
    $options->{unmapped_object_adaptor}->store(@$unmapped_objects);
  }

  $Helper->log('Creating final xrefs', 0, 'append_date');
  create_final_xrefs($object_transcript_hits, $xrefs, $xref_db, $options, $Helper);
  $Helper->log('Loading xrefs info DB', 0 , 'append_date');
#   if (scalar @$xrefs) {
#     store_xrefs($xrefs, $xref_db, $options->{transc_edb_id}, $options->{analysis}, $options->{transcript_xref_id}, $options);
#   }

  print_unmapped_counts($unmapped_counts);
  print_xrefs_per_array($options->{xref_object}, $options->{arrays_per_object}, $object_transcript_hits);
  print_most_mapped_transcripts(scalar(@{$transcripts}), $object_transcript_hits, $options->{xref_object});
  print_most_mapped_probes($object_transcript_hits, $options->{xref_object}, $options->{max_transcripts});

  add_mart_displayable_status($options->{array_names}, $options->{vendor}, $xref_db);
  $Helper->log_header("Completed Transcript $options->{xref_object} annotation for @{$options->{array_names}}", 0, 'append_date');
  return;
}

=head2

  Description: Online help message

=cut

sub usage {

  print << 'EOF';
Maps probe probes to transcripts.

perl $0 {options}

Options ([..] indicates optional):

READING TRANSCRIPTS:
--transcript_host            The database server to read transcripts from.
[--transcript_port]          The port to use for reading transcripts. Defaults to 3306.
--transcript_user            Database username for reading transcripts.
--transcript_pass            Password for transcript_user, if required.
--transcript_dbname          Database name to read transcripts from.
[--transcript_multi_species] Indicates that the transcript database is multi-species
[--transcript_species_id]    Species ID to use top access multi-species data

READING ARRAYS:
--probe_host            The database server to read probe features from.
[--probe_port]          The port to use for reading probe features. Defaults to 3306.
--probe_user            Database username for reading probe featuress.
--probe_pass            Password for probe_user, if required.
--probe_dbname          Database name to read probe features from.
[--probe_multi_species] Indicates that the transcript database is multi-species
[--probe_species_id]    Species ID to use top access multi-species data

WRITING XREFS:
--xref_host            The database server to write xrefs to.
[--xref_port]          The port to use for writing xrefs.. Defaults to 3306.
--xref_user            Database username for xrefs. Must allow writing.
--xref_pass            Password for xref_user, if required.
--xref_dbname          Database name to write xrefs to.
[--xref_multi_species] Indicates that the transcript database is multi-species
[--xref_species_id]    Species ID to use top access multi-species data

Note that if no probe_host, xref_host etc is specified, probe features will be read from,
and xrefs written to, the database specified by the transcript_* parameters.

Also, triage information will be written to the unmapped_object & unmapped_reason tables
in the xref database, unless the -no_triage option is specified.

GENERAL MAPPING OPTIONS:

[--mismatches]      Allow up to this number of mismatches, inclusive.
Defaults to 1.
[--utr_length]      Search this many bases downstream of the transcript
coding region as well. Defaults to 2000. Specify 'annotated' to use annotated lengths.
[--max_probesets]   Don't store mappings to any 'promiscuous' probesets that map
to more than this number of transcripts. Defaults to 100.
[--arrays]          Mandatory. Space separated list of arrays of same format e.g. AFFY or AFFY_ST etc.
[--threshold]       Fraction of probes per probeset that have to map. Default 0.5
MISCELLANEOUS:
[--delete]          Delete existing xrefs and object_xrefs, and entries in unmapped_object.
No deletion is done by default.
[--force_delete]    Forces deletion of all unmapped object info even if using a subset of arrays.
[--max_transcripts] Only use this many transcripts. Useful for debugging.
[--no_triage]       Don't write to the unmapped_object/unmapped_reason tables.
[--health_check]    Only do sanity checks, then stop. Useful for capthing errors before nohuping the process proper.
[--temp_dir]        Directory to store large temporary files
[--help]            This text.
EOF

  exit(0);
}

=head2 get_options

  Decription: parses the command line, checks for sanity
  ReturnType: Hash ref

=cut

sub get_options {
  my $options = {};

# Default options
  $options->{reg_verbose} = 0;
  ($options->{transcript_multi_species}, $options->{xref_multi_species}, $options->{probe_multi_species}) = (0,0,0);
  ($options->{transcript_species_id}, $options->{xref_species_id}, $options->{probe_species_id}) = (1,1,1);
  $options->{transcript_port} = 3306;
  $options->{probe_port} = 3306;
  $options->{xref_port} = 3306;
  $options->{max_mismatches} = 1;
  $options->{max_transcripts} = 100;
  $options->{mapping_threshold} = 0.5;
  $options->{array_config} = {
    probeset_arrays      => undef,
    linked_arrays        => undef,
    sense_interrogation  => undef,
  };
  $options->{utr_extends} = {
    3 => undef,
    5 => undef,
  };

#Set these to undef so we can allow no estimated UTR
#By setting these to 0 using the params
  $options->{unannotated_utrs} = {
    3 => undef,
    5 => undef,
  };
  $options->{array_names} = [];

  my @tmp_args = @ARGV;

  GetOptions(
    'transcript_host=s'      => \$options->{transcript_host},
  'transcript_user=s'      => \$options->{transcript_user},
  'transcript_port=i'      => \$options->{transcript_port},
  'transcript_pass=s'      => \$options->{transcript_pass},
  'transcript_dbname=s'    => \$options->{transcript_dbname},
  'transcript_species_id=i' => \$options->{transcript_species_id},
  'transcript_multi_species' => \$options->{transcript_multi_species},
  'probe_host=s'           => \$options->{probe_host},
  'probe_user=s'           => \$options->{probe_user},
  'probe_port=i'           => \$options->{probe_port},
  'probe_pass=s'           => \$options->{probe_pass},
  'probe_dbname=s'         => \$options->{probe_dbname},
  'probe_species_id=i' => \$options->{probe_species_id},
  'probe_multi_species' => \$options->{probe_multi_species},
  'xref_host=s'            => \$options->{xref_host},
  'xref_user=s'            => \$options->{xref_user},
  'xref_port=i'            => \$options->{xref_port},
  'xref_pass=s'            => \$options->{xref_pass},
  'xref_dbname=s'          => \$options->{xref_dbname},
  'xref_species_id=i' => \$options->{xref_species_id},
  'xref_multi_species' => \$options->{xref_multi_species},
  'reg_file=s'             => \$options->{reg_file},
  'reg_host=s'             => \$options->{reg_host},
  'reg_user=s'             => \$options->{reg_user},
  'reg_pass=s'             => \$options->{reg_pass},
  'reg_port=i'             => \$options->{reg_port},
  'reg_verbose'            => \$options->{reg_verbose},
  'species=s'              => \$options->{species},
  'vendor=s'               => \$options->{vendor},
  'format=s'               => \$options->{format},
  'mismatches=i'           => \$options->{max_mismatches},
  'annotated_3_prime_extend=s'       => \$options->{utr_extends}->{3},
  'annotated_5_prime_extend=s'       => \$options->{utr_extends}->{5},
  'calculate_utrs'         => \$options->{calc_utrs},
  'unannotated_5_utr=s'    => \$options->{unannotated_utrs}->{5},
  'unannotated_3_utr=s'    => \$options->{unannotated_utrs}->{3},
  'utr_multiplier=s'       => \$options->{utr_multiplier},#Make this for 5 and 3?
  'test_transcripts=i'     => \$options->{test_transcripts},
  'max_transcripts=i'      => \$options->{max_transcripts},
  'threshold=s'            => \$options->{mapping_threshold},
  'arrays=s{,}'            => $options->{array_names}, # this should take 1 or more space separate array names WARNING experimental feature!
  'import_edb'           => \$options->{import_edb},
  'delete'                 => \$options->{delete},
  'no_triage'              => \$options->{no_triage},
  'parallelise'            => \$options->{parallelise},
  'clean_up'               => \$options->{clean_up},
  'temp_dir=s'               => \$options->{temp_dir},
  'linked_arrays=i'          => \$options->{array_config}->{linked_arrays},
  'probeset_arrays=i'        => \$options->{array_config}->{probeset_arrays},
  'sense_interrogation=i'    => \$options->{array_config}->{sense_interrogation},
#Testing
  'slice=s'                => \$options->{test_slice},#Only for testing purposes!
  'transcript=s'           => \$options->{test_transcript_sid},
  'debug'                  => \$options->{debug},
#Helper params
  'tee'                    => \$main::_tee,
  'filename=s'               => \$options->{filename},
#add a reduced log to minimize memory usage?
  'help'                   => sub { pos2usage(-exitval => 0, -message => "Params are:\t@tmp_args"); }
  ) or pod2usage(
    -exitval => 1,
    -message => "Params are:\t@tmp_args"
  );

#Set log type so we are no over writing to the same files for different
#format, or custom formats

  # This is not working correctly, as is currently writing to default central log dir, not workdir
  # if this file is not defined, default to STDOUT, so is captured by lsf .out file
  #


  $options->{log_type} = $options->{format} || $$;

  $main::_log_file = $options->{filename};

  $Helper = new Bio::EnsEMBL::Funcgen::Utils::Helper;

  $options->{hostname} = `hostname`;
  chomp($options->{hostname});
  $Helper->log_header('Running on probe2transcript.pl on: '.$options->{hostname}, 0, 'append_date');
  $Helper->log("Params are:\t@tmp_args");

  if (! @{$options->{array_names}}) {
    croak("It is not wise to run all available arrays at the same time\nYou must supply a list of array names using -arrays, i.e. for all or a subset of a given array format(e.g. AFFY_UTR, AFFY_ST, ILLUMINA_WG)");
  }

  if (! $options->{vendor}) {
    croak ('Must supply a -vendor parameter e.g. AFFY');
  }

  if(defined $options->{format} && ! exists $array_format_config{$options->{format}}) {
    croak("-format is not valid:\t$options->{format}\nMust specify valid format e.g. ".join(', ', keys(%array_format_config)).
      "\nOr maybe you want to use -probeset_arrays, -linked_arrays and -sense_interrogation to define the format parameters?\n");
  }

  if(! ($options->{array_config}->{probeset_arrays} &&
        $options->{array_config}->{linked_arrays} &&
        $options->{array_config}->{sense_interrogation})
     && ! $options->{format}) {
    croak('You must specify a valid format parameter if you are not using -probeset_arrays, -linked_arrays and -sense_interrogation\n');
  }

  foreach my $key (keys %{$options->{array_config}}) {
    if(! defined $options->{array_config}->{$key}) {
      if(exists $array_format_config{$options->{format}}) {
        $options->{array_config}->{$key} = $array_format_config{$options->{format}}{$key};
      } else{
        croak("Cannot find default $options->{key} config for $options->{format} format");
      }
    }
  }

  $options->{xref_object} = ($options->{array_config}{probeset_arrays}) ? 'ProbeSet' : 'Probe';

  if($options->{reg_host} && $options->{reg_file}) {
    croak('You have specified confliciting parameters -reg_file -reg_host');
  }

  if(($options->{reg_host} || $options->{reg_file}) && ($options->{probe_dbname} || $options->{xref_dbname} || $options->{transcript_dbname})) {
    croak('You have specified conflicting paramters -reg_dbname and -probe_dbname or -transcript_dbname or -xref_dbname');
  }

  if($options->{reg_host} && ! ($options->{reg_user} && $options->{reg_pass})) {
    croak('Must provide at least a -reg_user -reg_pass (optional -reg_port -reg_verbose) if loading from db');
  }

  if(! $options->{species}) {
    croak('Must provide a -species');
  }

  if(!$options->{reg_file} && !$options->{reg_host}) {
    if (!$options->{transcript_user} || !$options->{transcript_dbname} || !$options->{transcript_host}) {
      croak("You must specify a -transcript_user -transcript_dbname -transcript_host\n");
    }
    if(!$options->{xref_user} || !$options->{xref_dbname} || !$options->{xref_host}) {
      croak("You must specify a -xref_user -xref_dbname and -xref_host\n");
    }
  }

  if($options->{test_slice} && $options->{test_transcript_sid}) {
    croak('Can only run in one test mode, please specify -slice or -transcript');
  }

  if(defined $options->{utr_extends}->{3} && defined $options->{utr_extends}{5} && $options->{utr_multiplier}) {#Can't have all
    croak('You cannot set both -3/5_prime_extend values and a -utr_multiplier');
  }
  elsif(!(defined  $options->{utr_extends}->{3} || defined $options->{utr_extends}{5} || defined $options->{utr_multiplier})) {#Can't have none
    croak("You must set some extension rules using  -3/5_prime_extend values and/or -utr_multiplier\n".
      "Set -utr_multiplier to 0 and omit -3/5_prime_extend to run against UTR only\n");
  }
  else{
    $Helper->log('You have specified -utr_multiplier and a -3|5_prime_extend, -3|5_prime_extend will override where appropriate');
  }

#Multiplier needs to be a pisitive real number
  if(defined $options->{utr_multiplier} && $options->{utr_multiplier} !~ /-*[0-9]+[\.0-9]*/) {
    croak("-utr_multiplier must be a positive real number:\t$options->{utr_multiplier}");
  }

#Validate extend params
  for my $end (3, 5) {
    if(defined $options->{utr_extends}->{$end} && $options->{utr_extends}{$end} =~ /\D+/) {
      croak("Invalid -${end}_prime_extend parameter(".$options->{utr_extends}{$end}.").  Must be a number(bp)");
    }
  }

#Can't use both default unannotated UTRs and calculate
  if($options->{unannotated_utrs}->{5} && $options->{unannotated_utrs}{3} && $options->{calc_utrs}) {
    croak('You cannot set both -unannotated_5/3utr values and -calculate_utrs');
  }

#Validate unannotated defaults
  for my $end (3, 5) {
    if(defined $options->{unannotated_utrs}->{$end}) {
      if($options->{unannotated_utrs}->{$end} =~ /^\D+$/) {
        croak("Invalid -unannotated_${end}_utr parameter(".$options->{unannotated_utrs}{$end}.").  Must be a number(bp)");
      }
      else{
        $Helper->log("Setting ${end} unannotated UTR length to ".$options->{unannotated_utrs}{$end});
      }
    }
    else{
      if(! $options->{calc_utrs}) {
        $Helper->log("Defaulting unannotated ${end} UTR length to 0");
        $options->{unannotated_utrs}->{$end} = 0;
      }
    }
  }

  return $options;
}

=head2 get_databases

  Description: Connects to databases
  Returntype: An array ref containing 3 Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor objects

=cut

sub get_databases {
  my ($options) = @_;
  my ($probe_db, $transcript_db, $xref_db);

  # Check for a registry
  if($options->{reg_file} || $options->{reg_host}) {
    my $reg = 'Bio::EnsEMBL::Registry';
    if($options->{reg_file}) {
      $Helper->log("Loading registry from:\t".$options->{reg_file});
      $reg->load_all($options->{reg_file}, $options->{reg_verbose});
    } else{
      $reg->load_registry_from_db(
        -host    => $options->{reg_host},
        -port    => $options->{reg_port} || 3306,
        -user    => $options->{reg_user},
        -pass    => $options->{reg_pass},
        -verbose => $options->{reg_verbose},
      );
    }

    $transcript_db = $reg->get_DBAdaptor($options->{species}, 'Core');
    $xref_db       = $reg->get_DBAdaptor($options->{species}, 'Funcgen');
    $probe_db = $xref_db;
  } else{
    $transcript_db = Bio::EnsEMBL::DBSQL::DBAdaptor->new(
      -host    => $options->{transcript_host},
      -port    => $options->{transcript_port},
      -user    => $options->{transcript_user},
      -pass    => $options->{transcript_pass},
      -dbname  => $options->{transcript_dbname},
      -species => $options->{species},
      -multispecies_db => $options->{transcript_multi_species},
      -species_id => $options->{transcript_species_id}
    );

    $xref_db = Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor->new(
      -host => $options->{xref_host},
      -port   => $options->{xref_port},
      -user   => $options->{xref_user},
      -pass   => $options->{xref_pass},
      -dbname => $options->{xref_dbname},
      -species => $options->{species},
      -multispecies_db => $options->{xref_multi_species},
      -species_id => $options->{xref_species_id}
    );

    if ($options->{probe_host} && $options->{probe_dbname} && $options->{probe_user}) {
      $probe_db = Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor->new(
        -host   => $options->{probe_host},
        -port   => $options->{probe_port},
        -user   => $options->{probe_user},
        -pass   => $options->{probe_pass},
        -dbname => $options->{probe_dbname},
        -species => $options->{species},
        -multispecies_db => $options->{probe_multi_species},
        -species_id => $options->{probe_species_id}
      );
    } else{
      $Helper->log('No probe DB params specified, defaulting to xref params');
      $probe_db = $xref_db;
    }
  }

  #Test the DBs here before starting
  $transcript_db->dbc->db_handle;
  $xref_db->dbc->db_handle;
  $probe_db->dbc->db_handle;

  #Allow automatic reconnection
  $probe_db->dbc->disconnect_if_idle(1);
  $transcript_db->dbc->disconnect_if_idle(1);
  $xref_db->dbc->disconnect_if_idle(1);

  return [$probe_db, $transcript_db, $xref_db];
}

=head2 get_arrays

  Arg 1: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
  Arg 2: string with vendor's name
  Arg 3: array ref of strings with microarray names
  Returntype: hash ref mapping string names to Bio::EnsEMBL::Funcgen::Array objects

=cut

sub get_arrays {
  my ($xref_db, $vendor, $array_names) = @_;
  my $first_array_format;
  my $aa = $xref_db->get_ArrayAdaptor();
  my %arrays = ();

  foreach my $name(@$array_names) {
    my $array = $aa->fetch_by_name_vendor($name, $vendor);

    if(! $array) {
      croak("Could not find $vendor $name array in DB");
    }
    $first_array_format ||= $array->format;
    if($array->format ne $first_array_format) {
      croak(
        "You must not map arrays of different formats in the same process. The first array format was: $first_array_format but one of them has the format " . $array->format
      );
    }

    $arrays{$name} = $array;
  }
  return \%arrays;
}

# =head2 get_external_db_id
# 
#   Arg1: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
#   Arg2: species string name
#   Arg3: MySQL database name
#   Arg4: schema build string
#   Arg5: import_edb: boolean determines whether to create new entry in xref system if none found
#   Returntype: ID number of external id in external_db table (xref system)
# 
# =cut
# 
# sub get_external_db_id {
#   my($xref_db, $species, $edb_name, $schema_build, $import_edb) = @_;
#   my $transc_edb_display_name = 'EnsemblTranscript';
#   my $edb_display             = $transc_edb_display_name;
# 
#   #Check for external_db records for species DBs
#   my $sql = "
#   SELECT
#     external_db_id
#   FROM
#     external_db
#   WHERE
#     db_name='$edb_name'
#     AND db_release='$schema_build'
#   ";
#   my @ids = @{$xref_db->dbc->db_handle->selectall_arrayref($sql)};
#   if (scalar @ids > 0) {
#     return $ids[0][0];
#   }
# 
#   if(! $import_edb) {
#     croak("Could not find current external_db $edb_name $schema_build from available versions.\nMaybe you have mis-spelt the -trans-species or you may need to manually add the external_db to the table and master file:\n\n$sql\n\n");
#   } else {
#     # Insert database details into xref system
#     $sql = "
#     INSERT
#       INTO external_db
#         (db_name, db_release, status, dbprimary_acc_linkable, priority, db_display_name, type)
#       VALUES
#         ('$edb_name', '$schema_build', 'KNOWNXREF', 1, 5, '$edb_display', 'MISC')
#     ";
#     $Helper->log("Importing external_db using: $sql");
#     $xref_db->dbc->db_handle->do($sql);
#     return $xref_db->db_handle->last_insert_id();
#   }
# }

=head2 get_or_create_analysis

  Arg1: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
  Returntype: Bio::EnsEMBL::Analysis object

=cut

sub get_or_create_analysis {
  my ($xref_db) = @_;
  my $analysis_adaptor = $xref_db->get_AnalysisAdaptor();
  my $analysis = $analysis_adaptor->fetch_by_logic_name('probe2transcript');

  if (!$analysis) {
    my $id = $analysis_adaptor->store(Bio::EnsEMBL::Analysis->new(
        -logic_name    => 'probe2transcript',
        -program       => 'probe2transcript.pl',
        -description   => 'Microarray probes from manufacturers are aligned to the genome by Ensembl, if the probe sequences are provided. The mapping is a two-step procedure outlined <a href="/info/genome/microarray_probe_set_mapping.html">here</a>.',
        -displayable   => '0')
    );
    $analysis = $analysis_adaptor->fetch_by_logic_name('probe2transcript');
  }
  return $analysis;
}

=head2 get_transcripts

  Arg1: Bio::EnsEMBL::DBSQL::DBAdaptor object
  Arg2: string describing a slice (see Bio::EnsEMBL::DBSQL::SliceAdaptor::fetch_by_name)
  Arg3: Ensembl transcript stable identifier
  Returntype: Array ref of Bio::EnsEMBL::Transcript objects

=cut

sub get_transcripts {
  my ($transcript_db, $test_slice, $test_transcript_sid) = @_;
  my $transcript_adaptor = $transcript_db->get_TranscriptAdaptor();
  my $slice_adaptor = $transcript_db->get_SliceAdaptor();
  my $transcripts;

  # If running in testing mode only select a subset of existing transcripts
  if($test_slice) {
    $Helper->log("Running in test mode with slice:\t$test_slice\n".
      "WARNING:\tPromiscuous probesets will not be caught! Calculated UTRs will be wrong!");
    #Need to add better text here when we have implemented parallel runs
    my $slice = $slice_adaptor->fetch_by_name($test_slice);
    if (! defined $slice) {
      croak("Could not get slice from the DB:\t$slice");
    }
    $transcripts = $transcript_adaptor->fetch_all_by_Slice($slice);
  } elsif($test_transcript_sid) {
    $Helper->log("Running test mode with transcript:\t$test_transcript_sid\n".
      "WARNING:\tPromiscuous probeset will not be caught!\n".
      "WARNING:\t--calc_utrs will not work");

    $transcripts = $transcript_adaptor->fetch_by_stable_id($test_transcript_sid);
  } else{
    $transcripts = $transcript_adaptor->fetch_all();
  }

  # Count transcripts
  if (scalar @$transcripts == 0) {
    croak('Could not find any transcripts');
  }
  $Helper->log('Identified '.scalar(@$transcripts).' transcripts for probe mapping');

  # Sort by stable id
  my @final = sort {$a->stable_id cmp $b->stable_id} @$transcripts;
  return \@final;
}

# =head2 get_transcript_xreF_ids
# 
#   Arg1: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
#   Arg2: Xref external DB id
#   Returntype: Hashref of transcript stable ID => Funcgen xref_id for all transcripts
#   in the xref table
# 
# =cut
# 
# sub get_transcript_xref_ids {
#   my ($xref_db, $transc_edb_id) = @_;
#   my $hash = {};
#   my $sql = "
#   SELECT
#     dbprimary_acc, xref_id
#   FROM
#     xref
#   WHERE
#     external_db_id = $transc_edb_id;
#   ";
#   foreach my $row (@{$xref_db->dbc->db_handle->selectall_arrayref($sql)}) {
#     $hash->{$row->[0]} = $row->[1];
#   }
#   return $hash;
# }
# 
# =head2 check_xrefs
# 
#   Description: Checks whether all known transcripts are stored in the Xref table
#   Arg1: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
#   Arg2: Xref external DB ID
#   Arg3: Array ref of Bio::EnsEMBL::Transcript objects
#   Arg4: Hash ref of stable id => Funcgen xref_id
# 
# =cut
# 
# sub check_xrefs {
#   my ($xref_db, $transc_edb_id, $transcripts, $transcript_xref_id) = @_;
# 
#   for my $transcript (@$transcripts) {
# 
#     if (! defined $transcript_xref_id->{$transcript->stable_id()}) {
#       croak('Transcript absent from xref table: '.$transcript->stable_id().
#         ", from external db: $transc_edb_id\n");
#     }
#   }
#   return;
# }

# =head2 delete_existing_xrefs
# 
#   Description: Delete existing xrefs & object xrefs & unmapped objects. Use user-specified arrays if
#   defined, otherwise all arrays.
#   Arg: Array ref of microarray names:
# 
# =cut
# 
# sub delete_existing_xrefs {
#   my ($arrays) = @_;
# 
# # Don't restrict to db_version as this would result in DBEntries/UnmappedObjects for old
# # releases persisting.
#   while (my $array = pop @$arrays) {
#     if (scalar @$arrays) {
#       $Helper->rollback_ArrayChips($array->get_ArrayChips, 'probe2transcript', undef, undef, 1, 0);
#     } else {
#       $Helper->rollback_ArrayChips($array->get_ArrayChips, 'probe2transcript', undef, undef, 0, 1);
#     }
#   }
#   return;
# }

# =head2 check_existing_and_exit
# 
#   Description: Check if there are already xrefs defined, and exit if there are.
#   Arg1: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
#   Arg2: Name of core database
#   Arg3: Hash ref containing:
#    - array_names: array ref
#    - array_config: hash ref with vendor array configs
#    - xref_object: "probe" or "probe_set"
# 
# =cut
# 
# sub check_existing_and_exit {
#   my ($xref_db, $transc_edb_name, $options) = @_;
# # Use user-specified arrays if defined, otherwise all arrays.
# # Assumes external_db.dbname == probe_array.name
#   my $probe_join = ($options->{array_config}{probeset_arrays}) ? 'p.probe_set_id' : 'p.probe_id';
# 
#   my $sql = "
#   SELECT
#     COUNT(*)
#   FROM
#      xref x
#      JOIN object_xref ox USING(xref_id)
#      JOIN external_db e USING(external_db_id)
#      JOIN probe p ON (ensembl_id = $probe_join)
#      JOIN array_chip ac USING(array_chip_id)
#      JOIN array a USING(array_id)
#   WHERE
#      e.db_name = '$transc_edb_name'
#      AND ox.ensembl_object_type= '$options->{xref_object}'
#      AND ox.linkage_annotation!= 'ProbeTranscriptAlign'
#      AND a.name=?
#   ";
# 
#   my $xref_sth = $xref_db->dbc()->prepare($sql);
# 
#   foreach my $array (@{$options->{array_names}}) {
#     $xref_sth->execute($array);
#     my $cnt = $xref_sth->fetchrow_array();
#     if ($cnt > 0) {
#       warn "Array $array already has $cnt xrefs, exiting.\nThere may be other arrays with xrefs. Use -delete to remove them if required.\n";
#       exit(1);
#     }
#   }
#   $xref_sth->finish();
#   return;
# }

# =head2 check_probe_analysis_join
# 
#   Description: Checks that all probe_feature rows have a corresponding analysis entry
#   Arg1: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
# 
# =cut
# 
# sub check_probe_analysis_join {
#   my ($probe_db) = @_;
# 
#   my $sql = '
#   SELECT
#     DISTINCT analysis_id, logic_name
#   FROM
#     probe_feature pf
#     LEFT JOIN analysis a
#       USING(analysis_id)
#   ';
# 
#   foreach my $row (@{$probe_db->dbc->db_handle->selectall_arrayref($sql)}) {
#     my ($anal_id, $lname) = @$row;
#     if(! $lname) {
#       croak("Found probe_feature analysis without a corresponding analysis entry:\t$anal_id");
#     }
#   }
#   return;
# }


=head2 get_transcripts_per_probefeature

  Description: counts how many transcripts overlap a probe feature from the xref table
  Arg1: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
  Arg2: Hash ref containing:
  - array_names: array ref
  - transc_edb_id: id of the core database in the external_db table of the xref system
  Arg3: Output file handle

=cut

sub get_transcripts_per_probefeature {
  my ($xref_db, $options, $Helper) = @_;
  my $sql = '
  SELECT
    ensembl_id, dbprimary_acc
  FROM object_xref
    JOIN probe_feature
      ON probe_feature_id = ensembl_id
    JOIN probe
      USING(probe_id)
    JOIN array_chip
      USING(array_chip_id)
    JOIN array
      USING(array_id)
    JOIN xref
      USING(xref_id)
  WHERE
    ensembl_object_type = "ProbeFeature"
    AND array.name in ("'.join('", "', @{$options->{array_names}}).'")
    AND external_db_id = '. $options->{transc_edb_id};

  my $sth = $xref_db->dbc()->prepare($sql);
  $sth->execute();

  my %transcripts_per_probefeature = ();
  my ($probeset_id, $transcript_sid);
  $sth->bind_columns(\$probeset_id, \$transcript_sid);
  if ($debug) {
    $Helper->log($sql."\n");
  }
  while($sth->fetch()) {
    if ($debug) {
      $Helper->log("ALIGNMENT\t$probeset_id\t$transcript_sid\n");
    }
    # It is called probe set, but it is actually a probefeature id.
    $transcripts_per_probefeature{$probeset_id} ||= {};
    $transcripts_per_probefeature{$probeset_id}{$transcript_sid}++;
    # TODO Check for duplicates, i.e. check number == 1
  }

  return \%transcripts_per_probefeature;
}

=head2 cache_arrays_per_object

 Description: Stores the list of objects in each array
 Arg1: Bio::EnsEMBL::DBSQL::DBAdaptor object
 Arg2: Hash ref containing
 - array_names: array ref
 - array_config: hash ref with vendor configs
 Returntype: arrayref with three hashrefs:
 - List of array names for each object_id
 - Integer for each object_id
 - String name for each object_id

=cut

sub cache_arrays_per_object {
  my ($probe_db, $options) = @_;

  my $sql;
  if($options->{array_config}{probeset_arrays}) {
    # Find all probesets belonging to the chosen microarrays
    $sql = '
    SELECT
      probe_set_id, ps.name, a.name, count(p.probe_id)
    FROM
      probe p
      JOIN probe_set ps
       USING(probe_set_id)
      JOIN array_chip ac
        USING(array_chip_id)
      JOIN array a
        USING(array_id)
    WHERE
      a.name in ("'.join('", "', @{$options->{array_names}}).'")
    GROUP BY
      p.probe_set_id, a.name
    ';
  }
  else{
    # Find all probes belonging to the chosen microarrays
    # Sometimes the same probe has different names across arrays, hence we concatenate those
    $sql = '
    SELECT
      p.probe_id, GROUP_CONCAT(p.name SEPARATOR "#"), a.name, count(p.probe_id)
    FROM
      probe p
      JOIN array_chip ac
        USING(array_chip_id)
      JOIN array a
        USING(array_id)
    WHERE
      a.name in ("'.join('", "', @{$options->{array_names}}).'")
    GROUP BY
      p.probe_id, a.name
    ';
  }

  my $sth = $probe_db->dbc()->prepare($sql);
  my ($object_id, $array, $probeset_size, $object_name);
  $sth->execute();
  $sth->bind_columns(\$object_id, \$object_name, \$array, \$probeset_size);

  my %arrays_per_object = ();
  my %probeset_sizes = ();
  my %object_names = ();
  while($sth->fetch()) {
    $arrays_per_object{$object_id} ||= [];
    push @{$arrays_per_object{$object_id}}, $array;
    $object_names{$object_id} ||= [];
    if($options->{array_config}{probeset_arrays}) {
      push @{$object_names{$object_id}}, $object_name;
      if ( defined $probeset_sizes{$object_id} && $probeset_size !=  $probeset_sizes{$object_id}) {
        warn("Found probeset(dbID=$object_id) with differing size between arrays:\ti".join(", ", @{$arrays_per_object{$object_id}})." and $array($probeset_size)\n");
      }
      if ($probeset_sizes{$object_id} < $probeset_size) {
        $probeset_sizes{$object_id} = $probeset_size;
      }
    } else {
      push @{$object_names{$object_id}}, (split/#/, $object_name);
    }
  }
  $sth->finish();

  return [\%arrays_per_object, \%probeset_sizes, \%object_names];
}

=head2 calculate_utrs

  Description: Computes the extension required on each gene. Fills in unannotated_utrs hashref
  Arg1: hashref, possibly with integer values associated to "5" and "3" constants.
  Arg2: Array ref of Bio::EnsEMBL::Transcript objects

  TODO Possibly pull this out into a separate function in the pipeline.
=cut

sub calculate_utrs {
  my ($unannotated_utrs, $transcripts) = @_;
  my %lengths = (
    5 => [],
    3 => []
  );

  # Get a list of all utr lengths from all transcripts, where defined
  foreach my $transcript(@$transcripts) {
    if(! defined $unannotated_utrs->{3} && $transcript->three_prime_utr) {
      push @{$lengths{3}}, $transcript->three_prime_utr->length;
    }
    if(! defined $unannotated_utrs->{5} && $transcript->five_prime_utr) {
      push @{$lengths{5}}, $transcript->five_prime_utr->length;
    }
  }

  # Compute a typical utr length from the measured values
  foreach my $side (5,3) {
    if(! defined $unannotated_utrs->{$side}) {
      my $count = scalar @{$lengths{$side}};
      my $zero_count = (scalar @$transcripts) - $count;
      $Helper->log("Seen $count ${side}' UTRs, $zero_count have length 0");

      if($count) {
        my ($mean, $remainder) = split/\./, mean($lengths{$side});
        if ($remainder =~ /^[5-9]/) {
          $mean++;
        }
        my $median = median($lengths{$side});
        $unannotated_utrs->{$side}  = ($mean > $median)  ? $mean : $median;
        $Helper->log("Calculated default unannotated ${side}' UTR length:\t$unannotated_utrs->{$side}");
      } else{
        croak('Found no 5\' UTRs, you must specify a -unannotated_5_utr');
      }
    }
  }

  return;
}

# =head2 write_extended_transcripts_into_file
# 
#   Description: Dumps transcript regions into sorted BED file
#   Stores a hash ref into the options hash ref
#   Arg1: Array ref of Bio::EnsEMBL::Transcript objects
#   Arg2: Filename to be written into
#   Arg3: Hash ref to collect stats
# 
# =cut
# 
# sub write_extended_transcripts_into_file {
#   my ($transcripts, $filename, $options) = @_;
# 
#   $options->{flanks} = {};
#   my $utr_counts = {};
#   $utr_counts->{3} = [];
#   $utr_counts->{5} = [];
# 
#   # Write each transcript into file
#   my ($fh0, $filename0) = tempfile();
#   foreach my $transcript (@$transcripts) {
#     print $fh0 write_extended_transcript($transcript, $utr_counts, $options)."\n";
#   }
# 
#   # Sort by chromosome name then start coordinate
#   run("sort -k1,1 -k2,2n $filename0 > $filename");
#   close $fh0;
#   unlink $filename0;
# 
#   # Prints out some random stats
#   foreach my $end(5, 3) {
#     my $total_length = 0;
#     foreach my $utr_count (@{$utr_counts->{$end}}) {
#       $total_length += $utr_count;
#     }
#     my $num_utrs = scalar(@{$utr_counts->{$end}});
#     my $average = ($num_utrs) ? ($total_length/$num_utrs) : 0;
#     $Helper->log("Seen $num_utrs $end prime UTRs with and average length of $average");
#   }
# 
#   return;
# }

# =head2 write_extended_transcript
# 
#   Arg1: Bio::EnsEMBL::Transcript object
#   Arg2: Hash ref for UTR stats collection
#   Arg3: Hash ref to collect stats
#   Returntype: line for BED file
# 
# =cut
# 
# sub write_extended_transcript {
#   my ($transcript, $utr_counts, $options) = @_;
#   my $transcript_sid = $transcript->stable_id;
# 
#   if ($debug) {
#     $Helper->log("\nDEBUG:\tTranscript ".$transcript_sid);
#   }
# 
#   # Computing UTR extension length
#   $options->{flanks}{$transcript_sid} = {};
#   foreach my $end(5, 3) {
#     $options->{flanks}{$transcript_sid}{$end} = extend_transcript($end, $transcript, $utr_counts, $options);
#   }
# 
#   my $new_start;
#   my $new_end;
#   # Check whether the transcript is on the postive/undefined or negative strand
#   if ($transcript->strand() >= 0) {
#     $new_start = $transcript->seq_region_start - $options->{flanks}{$transcript_sid}{5};
#     $new_end   = $transcript->seq_region_end + $options->{flanks}{$transcript_sid}{3};
#   } else {
#     $new_start = $transcript->seq_region_start - $options->{flanks}{$transcript_sid}{3};
#     $new_end = $transcript->seq_region_end + $options->{flanks}{$transcript_sid}{5};
#   }
# 
#   if ($new_start < 0) {
#     $new_start = 0;
#   }
# 
#   return join("\t", ($transcript->seq_region_name, $new_start, $new_end, $transcript->stable_id));
# }


=head2 extend_transcript

  Arg1: "5" or "3"
  Arg2: Bio::EnsEMBL::Transcript object
  Arg3: Hash ref for UTR stats collection
  Arg4: Hash ref to collect stats
  Returntype: Length of extension in basepairs

=cut

# sub extend_transcript {
#   my ($end, $transcript, $utr_counts, $options) = @_;
#   if($options->{utr_extends}{$end} || $options->{utr_multiplier} || $options->{unannotated_utrs}{$end}) {
#     my $method = ($end == 5) ? 'five' : 'three';
#     $method .= '_prime_utr';
#     my $utr = $transcript->$method;
# 
#     if(defined $utr) {
#       push @{$utr_counts->{$end}}, $utr->length;
#       if(defined $options->{utr_extends}{$end}) {
#         return $options->{utr_extends}{$end};
#       }
#       else{
#         return $utr->length * $options->{utr_multiplier};
#       }
#     } elsif (defined  $options->{unannotated_utrs}{$end}) {
#       return $options->{unannotated_utrs}{$end};
#     }
#   } else {
#     return 0;
#   }
# }

# =head2 dump_probe_features
# 
#   Description: Prints out bed file with probe feature data
#   Arg1: filename for destination file
#   Arg2: hashref with constants, in particular:
#   - xref_user
#   - xref_host
#   - xref_dbname
#   - xref_port
#   - xref_pass
# 
# =cut
# 
# sub dump_probe_features {
#   my ($filename2, $options) = @_;
#   my $names = join('", "', @{$options->{array_names}});
#   # Selecting all probe features for selected arrays in sorted BED format with useful metadata on the same line
#   my $sql = "
#   SELECT
#     seq_region.name, seq_region_start, seq_region_end, seq_region_strand, cigar_line, mismatches, probe_feature_id, probe_id, probe.name, probe_set_id, probe_set.name
#   FROM
#     probe_feature
#     JOIN probe
#       USING(probe_id)
#     LEFT JOIN probe_set
#       USING(probe_set_id)
#     JOIN array_chip
#       USING(array_chip_id)
#     JOIN array
#       USING(array_id)
#     JOIN seq_region
#       USING(seq_region_id)
#   WHERE
#     array.name IN (\"$names\")
#     AND array.vendor=\"$options->{vendor}\"
#   GROUP BY
#     probe_feature_id, probe_id, probe_set_id
#   ORDER BY
#     seq_region.name, seq_region_start
#   ";
# 
#   # Dump straight into file, without perl getting in the way
#   # Note the use of --quick which prevent the MySQL client from squirreling all the data in memory,
#   # instead this forces it to stream the data stright into the file
#   my $cmd = "mysql --quick -NB -u $options->{xref_user} -h $options->{xref_host} -D $options->{xref_dbname} -e '$sql'";
#   if (defined $options->{xref_port}) {
#     $cmd .= " -P $options->{xref_port}";
#   }
#   if (defined $options->{xref_pass}) {
#     $cmd .= " -p$options->{xref_pass}";
#   }
# 
#   ## Quick filter for trailing semi-colons in database names
#   run("$cmd | sed -e 's/;\$//' > $filename2");
#   return;
# }

=head2

  Description: OK this is where the action happens mostly. Goes through each overlap
  between transcript and probe feature, and collects data.
  Arg1: Array ref of Bio::EnsEMBL::Transcript objects
  Arg2: filehandle to the dump file created by bedtools
  Arg3: unmapped_counts: hashref
  Arg4: unmapped_objects: arrayref
  Arg5: xrefs: arrayref
  Arg6: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
  Arg7: hashref with constant parameters
  Arg8: filehandle to log file
  Returntype: composite hashref: object_id -> transcript stable id -> arrayref -> 2 integers

=cut

sub associate_probes_to_transcripts {
  my ($transcripts, $pf_transc_overlap_fh, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $Helper) = @_;
  # Number of processed transcripts
  my $index = 0;
  # Last percentage point to be processed for progress display
  my $last_pc = -1;
  # Last line to be read from the overlap file
  my $last_line = undef;
  # Hash ref with resuting overlaps
  my $object_transcript_hits = {};

  $Helper->log('% Complete:', 0, 'append_date');
  foreach my $transcript (@$transcripts) {
    if (defined $options->{test_transcripts} && $options->{test_transcripts}-- <= 0) {
      last;
    }
    $last_pc = print_progress($index++, scalar @{$transcripts}, $last_pc);
    # Stores overlaps temporarily
    my $transcript_feature_info = {};
    $last_line = examine_transcript($transcript, $transcript_feature_info, $pf_transc_overlap_fh, $last_line, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $Helper);
    compute_hits($transcript, $transcript_feature_info, $object_transcript_hits, $unmapped_objects, $unmapped_counts, $options, $Helper);
  }

  return $object_transcript_hits;
}

=head2 print_progress

  Description: Prints a little blurb on stdout each % of the way through
  Arg1: Number of transcripts processd
  Arg2: Total number of transcripts
  Arg3: last percentage threshold to be printed out

=cut

sub print_progress {
  my ($index, $total, $last_pc) = @_;
  my $pc = int ((100 * $index) / $total);

  if ($pc > $last_pc) {
    $Helper->log("$pc ", 0, 'append_date');
  }
  return $pc;
}

=head2

  Description: For one trasncript, goes through each overlap
  between that transcript and probe feature, and collects data.
  CalledBy : associate_probes_to_transcripts
  Arg1: Bio::EnsEMBL::Transcript object
  Arg2: hashref to be filled
  Arg3: filehandle to the dump file created by bedtools
  Arg4: last line of the above file to be read
  Arg5: hashref for unmapped
  Arg6: arrayref of unmapped
  Arg7: arrayref of xrefs => create_final_xrefs
  Arg8: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
  Arg9: hashref with constant parameters
  Arg10: filehandle to log file
  Returntype: String, last line read and first not processed (generally because it covers another transcript)

=cut

sub examine_transcript {
  my ($transcript, $transcript_feature_info, $pf_transc_overlap_fh, $last_line, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $Helper) = @_;

  my $range_registry = $options->{rr};
  $range_registry->flush();
  my @exons     = @{$transcript->get_all_Exons};
  foreach my $exon (@exons) {
    $range_registry->check_and_register('exonic', $exon->seq_region_start, $exon->seq_region_end);
  }
  my $first_exon = $exons[0];
  my $last_exon  = $exons[$#exons];

  my %exonutrs;
  my $transcript_sid = $transcript->stable_id;
  if ($debug) {
    $Helper->log("TRANSCRIPT $transcript_sid\n");
  }
  my $transcript_slice = $transcript->feature_Slice();
  my $slice            = $transcript_slice->expand($options->{$transcript_sid}{flanks}{5}, $options->{$transcript_sid}{flanks}{3});
  # Find flanking regions
  if ($transcript->strand == 1) {
    if ($options->{$transcript_sid}{flanks}{3}) {
      $exonutrs{3} = [$last_exon->seq_region_start, $slice->end];
    }
    if ($options->{$transcript_sid}{flanks}{5}) {
      $exonutrs{5} = [$slice->start, $first_exon->seq_region_end];
    }
  } else {
    if ($options->{$transcript_sid}{flanks}{3}) {
      $exonutrs{3} = [$slice->start(), $last_exon->seq_region_end];
    }
    if ($options->{$transcript_sid}{flanks}{5}) {
      $exonutrs{5} = [$first_exon->seq_region_start, $slice->end];
    }
  }

  # Mark flanking regions
  foreach my $end(3, 5) {
    if ($options->{$transcript_sid}{flanks}{$end}) {
      $range_registry->check_and_register("${end}_exonutr", @{$exonutrs{$end}});
    }
  }

  # Process last line read if defined
  # Note that in previous iteration of this function the reader found a line with a different
  # transcript stable ID, it passes this line over to future iterations.
  my $line = $last_line;
  my $overran = 0;
  my $count = 0;
  if (defined $line) {
    chomp $line;
    my ($tx_chr, $tx_start, $tx_end, $transcript_sid_2, $chr, $start, $end, $strand, $cigar, $mismatches, $feature_id, $probe_id, $probe_name, $probeset_id, $probeset_name) = split "\t", $line;
    if ($debug) {
      $Helper->log("LINE (2nd pass)| $line\n");
    }
    if ($transcript_sid_2 gt $transcript_sid) {
      $overran = 1;
    }
    if ($transcript_sid_2 eq $transcript_sid) {
      examine_probefeature($transcript, $feature_id, $probe_id, $probe_name, $probeset_id, $probeset_name, $start, $end, $strand, $cigar, $mismatches, $transcript_feature_info, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $Helper);
      $count++;
    }
  }

  # Process all following lines until you hit another transcript stable id
  while (!$overran && defined ($line = <$pf_transc_overlap_fh>)) {
    chomp $line;
    if ($debug) {
      $Helper->log("LINE:$line\n");
    }
    my ($tx_chr, $tx_start, $tx_end, $transcript_sid_2, $chr, $start, $end, $strand, $cigar, $mismatches, $feature_id, $probe_id, $probe_name, $probeset_id, $probeset_name) = split "\t", $line;
    if ($transcript_sid_2 gt $transcript_sid) {
      last;
    }
    if ($transcript_sid_2 eq $transcript_sid) {
      examine_probefeature($transcript, $feature_id, $probe_id, $probe_name, $probeset_id, $probeset_name, $start, $end, $strand, $cigar, $mismatches, $transcript_feature_info, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $Helper);
      $count++;
    }
  }

  if ($debug) {
    $Helper->log("DEBUG:\tProbeFeatures $count for ".join("\t", (map {$_->name} values(%{$options->{arrays}}))));
  }

  return $line;
}

=head2

  Description: For one overlap between a trasncript and a probe feature, collects data
  CalledBy: examine_transcript()
  Arg1: Bio::EnsEMBL::Transcript object
  Arg2: ProbeFeature DB id
  Arg3: Probe DB id
  Arg4: ProbeSet DB id
  Arg5: ProbeSet name, string
  Arg6: start of probe
  Arg7: end of probe
  Arg8: strand (1 or -1)
  Arg9: CIGAR string of probefeature alignment
  Arg10: number of mismatches
  Arg11: hashref to be filled
  Arg12: hashref of stats on unmapped objects
  Arg13: arrayref of Bio::EnsEMBL::UnmappedObject objects
  Arg14: arrayref for add_xref()
  Arg15: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
  Arg16: hashref with constant parameters
  Arg17: filehandle to log file

=cut

sub examine_probefeature {
  my ($transcript, $feature_id, $probe_id, $probe_name, $probeset_id, $probeset_name, $start, $end, $strand, $cigar_line, $mismatch_count, $transcript_feature_info,$unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $Helper) = @_;
  my $transcript_sid = $transcript->stable_id();
  my $transcript_version     = $transcript->version;
  my $log_name;

  if($options->{array_config}{probeset_arrays}) {
    $log_name       = $transcript_sid."\t(${probeset_name})\t${probe_id}";
  } else{
    $log_name       = $transcript_sid."\t(".join(',', @{$options->{object_names}->{$probe_id}}).")\t${probe_id}";
  }

  if($options->{array_config}{sense_interrogation}) {
    if($transcript->seq_region_strand == $strand) {
      if ($debug) {
        $Helper->log('Unmapped sense '.$log_name."\n");
      }
      return;
    }
  } elsif ($transcript->seq_region_strand != $strand) {
    if ($debug) {
      $Helper->log('Unmapped anti-sense '.$log_name."\n");
    }
    return;
  }

  my $mm_link_txt = '';
  my $mismatches = 0;
  if ($mismatch_count) {
    $mismatches = 1;
    $mm_link_txt = ' ('. $mismatch_count.' bp mismatch)';
  }

  if($cigar_line =~ /D/) {
    record_gapped_probefeature($feature_id, $probe_id, $probeset_id, $transcript, $transcript_feature_info, $mm_link_txt, $mismatches, $log_name, $unmapped_counts, $unmapped_objects, $options, $Helper);
  } else {
    record_aligned_probefeature($feature_id, $probe_id, $probeset_id, $start, $end, $cigar_line, $mismatch_count, $transcript_feature_info, $transcript, $mm_link_txt, $mismatches, $log_name, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $Helper);
  }
  return;
}

=head2

  Description: For one gapped overlap between a trasncript and a probe feature, collects data
  
  The data is returned by making changes to the hash referenced by 
  $transcript_feature_info instead of a return value.
  
  CalledBy: examine_probefeature
  Arg1: ProbeFeature DB id
  Arg2: Probe DB id
  Arg3: ProbeSet DB id
  Arg4: Bio::EnsEMBL::Transcript object
  Arg5: hashref to fill
  Arg6: Text string describing overlap
  Arg7: boolean (contains mismatches?)
  Arg8: string describing the overlapped pair
  Arg9: hashref of stats on unmapped objects
  Arg10: arrayref of Bio::EnsEMBL::UnmappedObject objects
  Arg11: hashref with constant parameters
  Arg12: filehandle to log file

=cut

sub record_gapped_probefeature {
  my ($feature_id, $probe_id, $probeset_id, $transcript, $transcript_feature_info, $mm_link_txt, $mismatches, $log_name, $unmapped_counts, $unmapped_objects, $options, $Helper) = @_;
  my $transcript_sid = $transcript->stable_id();

  if(exists $options->{transcripts_per_probefeature}{$feature_id}{$transcript_sid}) {
    if ($debug) {
      $Helper->log('Mapped Gapped ProbeFeature '.$log_name."\n");
    }
    if ($options->{array_config}{probeset_arrays}) {
      $transcript_feature_info->{$probeset_id}{$probe_id} ||= [0, 0];
      $transcript_feature_info->{$probeset_id}{$probe_id}->[0]++;
      $transcript_feature_info->{$probeset_id}{$probe_id}->[1] += $mismatches;
    } else {
      $transcript_feature_info->{$probe_id} ||= [];
      push @{$transcript_feature_info->{$probe_id}}, ["exon-exon match${mm_link_txt}", $mismatches];
    }
  } else {
    if ($debug) {
      $Helper->log('Unmapped Gapped ProbeFeature '.$log_name."\n");
    }
    cache_and_load_unmapped_objects(
      $options,
      $unmapped_counts,
      $unmapped_objects,
      $transcript_sid,
      'ProbeFeature',
      $feature_id,
      'Unmapped Gapped ProbeFeature',
      'Gapped ProbeFeature did not match transcript structure'
    );
  }
  # The real return value is in $transcript_feature_info
  return;
}

=head2

  Description: For one ungapped overlap between a trasncript and a probe feature, collects data
  
  The data is returned by making changes to the hash referenced by 
  $transcript_feature_info instead of a return value.
  
  It also stores xrefs.
  
  CalledBy: examine_probefeature()
  Arg1: ProbeFeature DB id
  Arg2: Probe DB id
  Arg3: ProbeSet DB id
  Arg4: start of probe
  Arg5: end of probe
  Arg6: CIGAR string
  Arg7: integer count of mismatches
  Arg8: hashref to fill
  Arg9: Bio::EnsEMBL::Transcript object
  Arg10: Text string describing overlap
  Arg11: boolean if contains mismatches
  Arg12: string describing the overlapped pair
  Arg13: hashref of stats on unmapped objects
  Arg14: arrayref of Bio::EnsEMBL::UnmappedObject objects
  Arg15: arrayref for add_xref()
  Arg16: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
  Arg17: hashref with constant parameters
  Arg18: filehandle to log file

=cut

sub record_aligned_probefeature {
  my ($feature_id, $probe_id, $probeset_id, $start, $end, $cigar_line, $mismatch_count, $transcript_feature_info, $transcript, $mm_link_txt, $mismatches, $log_name, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $Helper) = @_;
  my $five_mismatch  = 0;
  my $three_mismatch = 0;
  my $feature_start  = $start;
  my $feature_end    = $end;

  if($cigar_line =~ /(^[0-9]+)m/) {
    $five_mismatch = $1;
    $feature_start += $five_mismatch;
  }

  if($cigar_line =~ /([0-9]+$)m/) {
    $three_mismatch = $1;
    $feature_end -= $three_mismatch;
  }

  my $min_overlap  = ($end - $start + 1 - $options->{max_mismatches} + ($mismatch_count - $five_mismatch - $three_mismatch));
  my $exon_overlap = $options->{rr}->overlap_size('exonic', $feature_start, $feature_end);
  my $flank_end     = 0;
  my $flank_overlap = 0;

  foreach my $side (3, 5) {
    if ($options->{$transcript->stable_id}{flanks}{$side}) {
      $flank_overlap = $options->{rr}->overlap_size("${side}_exonutr", $start, $end);
    }
    if ($flank_overlap) {
      $flank_end = $side;
      last;
    }
  }

  if (($exon_overlap >= $min_overlap) ||
    ($flank_overlap >= $min_overlap)) {
    my $linkage_annotation;

    if ($exon_overlap && $flank_overlap) {
      $linkage_annotation = "exon/${flank_end}' flank boundary${mm_link_txt}";
    } elsif ($exon_overlap) {
      $linkage_annotation = "exon${mm_link_txt}";
    } else {                                #only flank over lap
      $linkage_annotation = "${flank_end}' flank${mm_link_txt}";
    }

    if ($options->{array_config}{probeset_arrays}) {
    
      # This is the output of the function
      $transcript_feature_info->{$probeset_id}{$probe_id} ||= [0, 0];
      $transcript_feature_info->{$probeset_id}{$probe_id}->[0]++;
      $transcript_feature_info->{$probeset_id}{$probe_id}->[1] += $mismatches;
    } else {
      $transcript_feature_info->{$probe_id} ||= [];
      push @{$transcript_feature_info->{$probe_id}}, [$linkage_annotation, $mismatches];
    }
    if ($debug) {
      $Helper->log("Mapped\t$probe_id\t$probeset_id\t".$transcript->stable_id()."\n");
    }
    add_xref($transcript->stable_id, $feature_id, 'ProbeFeature', $linkage_annotation, $xrefs, $xref_db, $options);
  } else {
    my ($summary, $region);

    if (!( $exon_overlap || $flank_overlap)) {
      $summary = 'intronic';
      $region  = 'intronic region';
    } elsif ($exon_overlap) {
      if (! $flank_overlap) {
        $summary = 'exon boundary';
        $region  = $summary;
      } else {
        $summary = "${flank_end}' flank boundary";
        $region  = $summary;
      }
    } else {
      $summary = "${flank_end}' flank boundary";
      $region  = $summary;
    }
    if ($debug) {
      $Helper->log("Unmapped $summary ".$log_name."\n");
    }
    cache_and_load_unmapped_objects(
      $options,
      $unmapped_counts,
      $unmapped_objects,
      $transcript->stable_id,
      'ProbeFeature',
      $feature_id,
      "Unmapped $summary",
      "Probe mapped to $region of transcript"
    );
  }
  # The real return value is in $transcript_feature_info
  return;
}

=head2

  Description: Converts hash ref linking objects to hits into a more conveninent
  hash ref object -> transcript -> array ref -> 2 integers
  Arg1: Bio::EnsEMBL::Transcript object
  Arg2: hash ref linking objects to hits
  Arg3: hash ref to be filled
  Arg4: array ref of Bio::EnsEMBL::UnmappedObject objects
  Arg5: hash ref with stats on unmapped objects
  Arg6: hash ref of global constants
  Arg7: File handle for detailed output

=cut

sub compute_hits {
  my ($transcript, $transcript_feature_info, $object_transcript_hits, $unmapped_objects, $unmapped_counts, $options, $Helper) = @_;

  foreach my $object_id (keys %$transcript_feature_info) {
    compute_hits_2($object_id, $transcript, $transcript_feature_info, $object_transcript_hits, $unmapped_objects, $unmapped_counts, $options, $Helper);
  }

  return;
}

=head2 compute_hits_2

  Description: Converts hash ref linking an object to hits into a more conveninent
  hash ref object -> transcript -> array ref -> 2 integers
  Arg1: Ensembl DB ID
  Arg2: Bio::EnsEMBL::Transcript object
  Arg3: hash ref linking objects to hits
  Arg4: hash ref to be filled
  Arg5: array ref of Bio::EnsEMBL::UnmappedObject objects
  Arg6: hash ref with stats on unmapped objects
  Arg7: hash ref of global constants
  Arg8: File handle for detailed output

=cut

sub compute_hits_2 {
  my ($object_id, $transcript, $transcript_feature_info, $object_transcript_hits, $unmapped_objects, $unmapped_object_counts, $options, $Helper) = @_;

  # Count hits between object and transcript
  my $hits;
  if($options->{array_config}{probeset_arrays}) {
    $hits = scalar(keys %{$transcript_feature_info->{$object_id}});
  } else{
    $hits = scalar(@{$transcript_feature_info->{$object_id}});
  }

  my $probeset_size = $options->{probeset_sizes}{$object_id};

  # Verifiy whether the number of hits is above threshold
  if (($options->{xref_object} eq 'ProbeSet' && ($hits / $probeset_size) >= $options->{mapping_threshold})
        || ($hits && ($options->{xref_object} eq 'Probe'))) {
    # Success: store the hit information
    store_sufficient_hit($object_id, $transcript, $hits, $transcript_feature_info, $object_transcript_hits, $options, $Helper);
  } else {
    # Failure, store unmapped object information
    store_insufficient_hit($object_id, $transcript, $hits, $probeset_size, $unmapped_objects, $unmapped_object_counts, $options, $Helper);
  }

  return;
}

=head2 store_sufficeient_hit

  Description: Converts hash ref linking an object to a transcript into a more conveninent
  hash ref object -> transcript -> array ref -> 2 integers
  Arg1: Ensembl DB ID
  Arg2: Bio::EnsEMBL::Transcript object
  Arg3: Number of hits
  Arg4: hash ref linking objects to hits
  Arg5: hash ref to be filled
   made up of probesets
  Arg6: hash ref of global constants
  Arg7: File handle for detailed output

=cut

sub store_sufficient_hit {
  my ($object_id, $transcript, $hits, $transcript_feature_info, $object_transcript_hits, $options, $Helper) = @_;
  # Count mismatches
  my $num_mismatch_hits = 0;
  if($options->{array_config}{probeset_arrays}) {
    foreach my $value (values %{$transcript_feature_info->{$object_id}}) {
      if ($_->[1] == $_->[0]) {
        $num_mismatch_hits += 1;
      }
    }
  } else{
    foreach my $value (@{$transcript_feature_info->{$object_id}}) {
      if ($_->[1]) {
        $num_mismatch_hits += 1;
      }
    }
  }

  $object_transcript_hits->{$object_id}{$transcript->stable_id} = [$hits, $num_mismatch_hits];
  if ($debug) {
    $Helper->log("Sufficient hit\t$object_id\t".$transcript->stable_id()."\t$hits\t$num_mismatch_hits\n");
  }
  if ($options->{xref_object} eq 'Probe' && $hits == 1) {
    push @{$object_transcript_hits->{$object_id}{$transcript->stable_id}}, $transcript_feature_info->{$object_id}[0][0];
  }
}

=head2 store_insufficient_hit

  Description: Records a missed connection between object and transcript
  Arg1: Ensembl DB ID
  Arg2: Bio::EnsEMBL::Transcript object
  Arg3: Number of hits
  Arg4: Size of probeset
  Arg5: array ref of Bio::EnsEMBL::UnmappedObject objects
  Arg6: hash ref with stats on unmapped objects
   made up of probesets
  Arg7: hash ref of global constants
  Arg8: File handle for detailed output

=cut

sub store_insufficient_hit {
  my ($object_id, $transcript, $hits, $probeset_size, $unmapped_objects, $unmapped_object_counts, $options, $Helper) = @_;

  my $id_names = $object_id.'('.join(',', @{$options->{object_names}{$object_id}}).')';

  if ($debug) {
    $Helper->log("$id_names\t".$transcript->stable_id."\tinsufficient\t$hits/$probeset_size in ProbeSet\n");
  }

  cache_and_load_unmapped_objects(
    $options,
    $unmapped_object_counts,
    $unmapped_objects,
    $transcript->stable_id,
    'ProbeSet',
    $object_id,
    'Insufficient hits',
    "Insufficient number of hits $hits/$probeset_size in ProbeSet"
  );

}

=head2

  Description: Stores all objects with no assocation to a transcript into the unmapped
  table
  Arg1: hash ref of hash refs linking object_id x Bio::EnsEMBL::Transcript object => array ref
  Arg2: hash ref with stats on unmapped objects
  Arg3: array ref of Bio::EnsEMBL::UnmappedObject objects
  Arg4: hash ref of global constants
  Arg5: File handle for detailed output

=cut

sub log_unmapped_objects {
  my ($object_transcript_hits, $unmapped_counts, $unmapped_objects, $options, $Helper) = @_;

  # Skip if running in test mode
  if($options->{test_slice} || $options->{test_transcript_sid}) {
    my $tmp = $options->{test_slice} || $options->{test_transcript_sid};
    $Helper->log("Skipping log_unmapped_objects as we are running on a test on:\t${tmp}");
    return;
  }

  foreach my $object_id (keys %{$options->{arrays_per_object}}) {
    if (!exists $object_transcript_hits->{$object_id}) {
      log_unmapped_object($object_id, $unmapped_counts, $unmapped_objects, $options, $Helper);
    }
  }

  return;
}

=head2

  Description: Stores an object with no assocation to a transcript into the unmapped
  table
  Arg1: Ensembl ID of the object
  Arg2: hash ref with stats on unmapped objects
  Arg3: array ref of Bio::EnsEMBL::UnmappedObject objects
  Arg4: hash ref of global constants
  Arg5: File handle for detailed output

=cut

sub log_unmapped_object {
  my ($object_id, $unmapped_counts, $unmapped_objects, $options, $Helper) = @_;

  my $names = join(',', @{$options->{object_names}{$object_id}});
  $Helper->log("$options->{xref_object} $object_id($names)\tNo transcript mappings\n");
  cache_and_load_unmapped_objects(
    $options,
    $unmapped_counts,
    $unmapped_objects,
    'NO_TRANSCRIPT_MAPPINGS',
    $options->{xref_object},
    $object_id,
    'No transcript mappings',
    $options->{xref_object}.' did not map to any transcripts'
  );
}

=head2 remove_promiscuous_objects

  Description: Removes objects with too many hits from the list of candidate object+transcript hits
  Arg1: hash ref linking objects to a count
  Arg2: list of candidate xref hits
  Arg3: hash ref with stats on unmapped objects
  Arg4: array ref of Bio::EnsEMBL::UnmappedObject objects
  Arg5: hash ref with constant variables, in particular:
    * max_transcripts: integer cutoff
    * object_names: hash ref linking object_id => object name
    * probeset_sizes: hash ref linking object_id => integer size
    * xref_object: "Probe" or "ProbeSet"
  Arg6: File handle for detailed output
  Returntype: array ref of filtered hits

=cut

sub remove_promiscuous_objects {
  my ($object_transcript_hits, $unmapped_counts, $unmapped_objects, $options, $Helper) = @_;

  foreach my $object_id (keys %$object_transcript_hits) {
    my $object_transcript_count = scalar keys %{$object_transcript_hits->{$object_id}};
    if ($object_transcript_count > $options->{max_transcripts}) {
      foreach my $transcript_id (keys %{$object_transcript_hits->{$object_id}}) {
        my $pair_hit_count = $object_transcript_hits->{$object_id}{$transcript_id}[0];
        remove_promiscuous_object_transcript_pair($object_id, $transcript_id, $pair_hit_count, $object_transcript_count, $unmapped_counts, $unmapped_objects, $options, $Helper);
      }
      # Cleaning up unecessary hash ref, opening its contents to garbage collection
      delete $object_transcript_hits->{$object_id};
    }
  }
  return;
}

=head2 remove_promiscuous_object

  Description: Removes an object/transcript hit from the list of candidates because the
    object has too many other hits
  Arg1: EnsemblID
  Arg2: object_transcript_hits: list of candidate xref hits
  Arg3: unmapped_counts: hash ref with stats on unmapped objects
  Arg4: unmapped_objects: array ref of Bio::EnsEMBL::UnmappedObject objects
  Arg5: hash ref with constant variables, in particular:
    - max_transcripts: integer cutoff
    - object_names: hash ref linking object_id => object name
    - probeset_sizes: hash ref linking object_id => integer size
    - xref_object: "Probe" or "ProbeSet"
  Arg6: File handle for detailed output
  Returntype: array ref of filtered hits

=cut

sub remove_promiscuous_object_transcript_pair {
  my ($object_id, $transcript_id, $pair_hit_count, $object_transcript_count, $unmapped_counts, $unmapped_objects, $options, $Helper) = @_;

  my $id_names = $object_id.'('.join(',', @{$options->{object_names}{$object_id}}).')';
  my $probeset_size = $options->{probeset_sizes}->{$object_id};
  $Helper->log("$id_names\t$transcript_id\tpromiscuous\t$pair_hit_count/$probeset_size\tCurrentTranscripts".$object_transcript_count."\n");
  cache_and_load_unmapped_objects(
    $options,
    $unmapped_counts,
    $unmapped_objects,
    $transcript_id,
    'ProbeSet',
    $object_id,
    "Promiscuous $options->{xref_object}",
    "$options->{xref_object} maps to $object_transcript_count transcripts (max 100)."
  );

  return;
}

=head2

  Description: Transforms the filtered list of object+transcript hits into xrefs and
    loads those
  Arg1: hash ref of hash refs linking
    object_id x Bio::EnsEMBL::Transcript object => array ref
  Arg2: temporary array storage for xref objects about to be loaded
  Arg3: hash ref with constant variables, in particular:
    - object_names: hash ref linking object_id => object name
    - probeset_sizes: hash ref linking object_id => integer size
    - xref_object: "Probe" or "ProbeSet"

=cut

sub create_final_xrefs {
  my ($object_transcript_hits, $xrefs, $xref_db, $options, $Helper) = @_;

  foreach my $object_id (keys %$object_transcript_hits) {
    foreach my $transcript_id (keys %{$object_transcript_hits->{$object_id}}) {
      my $id_names = $object_id.'('.join(',', @{$options->{object_names}{$object_id}}).')';
      my ($hits, $num_mismatch_hits, $desc) = @{$object_transcript_hits->{$object_id}{$transcript_id}};

      my $linkage_annotation;
      if($options->{xref_object} eq 'ProbeSet') {
        my $probeset_size = $options->{probeset_sizes}->{$object_id};
        $linkage_annotation = "${hits}/${probeset_size} in probeset";
        if ($num_mismatch_hits) {
          if ($num_mismatch_hits == 1) {
            $linkage_annotation .= '(with 1 mismatched probe)';
          } else{
            $linkage_annotation .= "(with $num_mismatch_hits mismatched probes)";
          }
        }
      } else {
        if($hits > 1) {
          $linkage_annotation = "Matches $hits times";
          if ($num_mismatch_hits) {
            $linkage_annotation .= " ($num_mismatch_hits times with mismatches)";
          }
        } else{
          $linkage_annotation = 'Matches '. $desc;
        }
      }

      my $other_hits = (scalar keys %{$object_transcript_hits->{$object_id}}) - 1;
      if($other_hits >= 1) {
        my $plural = ($other_hits == 1) ? '' : 's';
        $linkage_annotation .= ". Matches $other_hits other transcript${plural}";
      }
      else{
        $linkage_annotation .= '. Maps uniquely to this transcript';
      }

      add_xref($transcript_id, $object_id, $options->{xref_object}, $linkage_annotation, $xrefs, $xref_db, $options);
      if($options->{xref_object} eq 'ProbeSet') {
        $Helper->log("$id_names\t$transcript_id\tmapped\t$hits/$options->{probeset_size}{$object_id}\n");
      } else {
        $Helper->log("$id_names\t$transcript_id\tmapped\t$hits\n");
      }
    }
  }
  return;
}

=head2 print_unmapped_counts

  Arg1: hash ref of hash refs linking:
    object_type x object name => integer count

=cut

sub print_unmapped_counts {
  my ($unmapped_counts) = @_;
  my $uo_string;

  foreach my $obj_type(keys %$unmapped_counts) {
    if ($obj_type eq 'Total') {
      next;
    }

    foreach my $uo_label(keys %{$unmapped_counts->{$obj_type}}) {
      $uo_string .= "\t\t\t\t${obj_type}\t${uo_label}\t".$unmapped_counts->{$obj_type}->{$uo_label}."\n";
    }
  }
  $uo_string .= "\t\t\t\tTotal\t".$unmapped_counts->{Total}."\n";
  $Helper->log("UnmappedObjects loaded:\n$uo_string");
  return;
}

=head2 print_xrefs_per_array

  Arg1: "Probe" or "ProbeSet"
  Arg2: hash ref linking object_id => array name
  Arg3: hash ref of hash refs linking
    object_id x Bio::EnsEMBL::Transcript object => array ref

=cut

sub print_xrefs_per_array {
  my ($xref_object, $arrays_per_object, $object_transcript_hits) = @_;

  $Helper->log('Counting xrefs');

  my %objects_per_array = ();
  my %total = ();
  my %covered_objects = ();
  foreach my $object_id (keys %$object_transcript_hits) {
    foreach my $array (@{$arrays_per_object->{$object_id}}) {
      $total{$array} ||= 0;
      $total{$array} += scalar keys %{$object_transcript_hits->{$object_id}};
      $covered_objects{$array} ||= {};
      $covered_objects{$array}{$object_id} = undef;
    }
  }

  foreach my $object_id (keys %$arrays_per_object) {
    foreach my $array (@{$arrays_per_object->{$object_id}}) {
      $objects_per_array{$array} ||= 0;
      $objects_per_array{$array}++;
    }
  }

  $Helper->log('Found '.scalar(keys(%$object_transcript_hits)).' hits');

  foreach my $aname(keys %total) {
    $Helper->log("$aname distinct $xref_object xrefs mapped(total xrefs):\t".
      scalar(keys(%{$covered_objects{$aname}}))."/$objects_per_array{$aname}($total{$aname})");
  }
  return;
}

=head2 print_most_mapped_transcripts

  Arg1: number of transcripts
  Arg2: hash ref of hash refs linking
    object_id x Bio::EnsEMBL::Transcript object => array ref
  Arg3: "Probe" or "ProbeSet"

=cut

sub print_most_mapped_transcripts {
  my ($total, $object_transcript_hits, $xref_object) = @_;
  my %transcript_xref_counts = ();

  foreach my $object_id (keys %$object_transcript_hits) {
    foreach my $transcript_id (keys %{$object_transcript_hits->{$object_id}}) {
      $transcript_xref_counts{$transcript_id}++;
    }
  }

  $Helper->log('Mapped '. scalar(keys(%transcript_xref_counts))."/$total transcripts ", 0, 'append_date');

#sort keys with respect to values.
  $Helper->log_header('Top 5 most mapped transcripts:');
  my @tids = sort { $transcript_xref_counts{$b} <=>  $transcript_xref_counts{$a} } keys %transcript_xref_counts;

  for my $i(0..4) {
    $Helper->log("$tids[$i] mapped $transcript_xref_counts{$tids[$i]} times");
  }
  return;
}

=head2 print_most_mapped_probes

  Arg1: hash ref of hash refs linking
        object_id x Bio::EnsEMBL::Transcript object => array ref
  Arg2:: "Probe" or "ProbeSet"

=cut
sub print_most_mapped_probes {
  my ($object_transcript_hits, $xref_object) = @_;
  my %transcripts_per_object = ();

  foreach my $object_id (keys %$object_transcript_hits) {
    $transcripts_per_object{$object_id} = scalar keys %{$object_transcript_hits->{$object_id}};
  }

  $Helper->log_header("Top 5 most mapped ${xref_object}s (no promiscuous):");
  my @xo_ids = sort { $transcripts_per_object{$b} <=>  $transcripts_per_object{$a} } keys %transcripts_per_object;
  my @xo_counts = sort { $b <=> $a } values %transcripts_per_object;
  my $num_ids = scalar(@xo_counts);

  for my $i(0..4) {
    $Helper->log("dbid $xo_ids[$i] mapped $xo_counts[$i] times");
  }
  return;
}

=head2

  Description: BioMart voodoo, don't ask me what this means
  Arg1: array ref of microarray names
  Arg2: vendor name
  Arg3: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object

=cut

sub add_mart_displayable_status {
  my ($array_names, $vendor, $xref_db) = @_;
  my $names_string = join('", "', @$array_names);
  my $sql="
  INSERT IGNORE
    INTO status
    SELECT
      a.array_id, 'array', sn.status_name_id
      FROM
        array a, status_name sn
      WHERE
        a.name in (\"$names_string\")
        AND a.vendor='$vendor'
        AND sn.name in ('MART_DISPLAYABLE')
  ";
  $Helper->log_header('Adding MART_DISPLAYABLE status entries');
  $xref_db->dbc->do($sql);
  return;
}

=head2 cache_and_load_unmapped_objects

  Description: Stores an objects into the unmapped_object table, with some caching
  Arg1: hash ref of global constants
  Arg2: hash ref with stats on unmapped objects
  Arg3: array ref of Bio::EnsEMBL::UnmappedObject objects
  Arg4: stable id to potential hit
  Arg5: "Probe", "ProbeSet" or "ProbeFeature"
  Arg6: Ensembl ID of the object
  Arg7: short string description
  Arg8: longer string description

=cut

sub cache_and_load_unmapped_objects {
  my ($options, $unmapped_counts, $unmapped_objects, $identifier, $object_type, $object_id, $summary, $description) = @_;
  if (! $options->{no_triage}) {
    my $um_obj = Bio::EnsEMBL::UnmappedObject->new(
      -type       => 'probe2transcript',
      -analysis   => $options->{analysis},
      -identifier => $identifier,
      -summary    => $summary,
      -full_desc  => $description,
      -ensembl_object_type => $object_type,
      -ensembl_id => $object_id,
      -external_db_id => $options->{transc_edb_id},
    );
    $unmapped_counts->{$um_obj->ensembl_object_type}{$um_obj->summary} ||= 0;
    $unmapped_counts->{$um_obj->ensembl_object_type}{$um_obj->summary}++;
    $unmapped_counts->{Total}++;
    push @{$unmapped_objects}, $um_obj;
    if(scalar(@{$unmapped_objects}) > 10000) {
      store_unmapped_objects($unmapped_objects, $options);
      @{$unmapped_objects} = ();
    }
  }
  return;
}

=head2 store_unmapped_objects

  Description: Stores unmapped object information into database
  Arg1: array ref of unmapped Ensembl objects
  Arg2: hash ref containing:
  - unmapped_object_adaptor: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
  - desc_to_id: hash ref associating an unmapped_reason description to its db id

=cut

sub store_unmapped_objects {
  my ($unmapped_objects, $options) = @_;

  if( scalar(@$unmapped_objects) == 0 ) {
    throw('Must call store with list of UnmappedObjects');
  }

  foreach my $unmapped_object ( @$unmapped_objects ) {
    set_unmapped_reason_id($unmapped_object, $options);
  }

  # Dump data into flat file
  my ($fh, $filename) = tempfile();
  foreach my $unmapped_object ( @$unmapped_objects ) {
    print $fh join("\t", ('\N', $unmapped_object->{'type'}, $unmapped_object->analysis->dbID, $unmapped_object->{'external_db_id'}, $unmapped_object->{'identifier'}, $unmapped_object->{'unmapped_reason_id'}, '\N', '\N', $unmapped_object->{'ensembl_id'}, $unmapped_object->{'ensembl_object_type'}, '\N'))."\n";
  }
  chmod 0644, $filename;
  $fh->autoflush;

  # Load file into DB
  my $cmd = "mysql -u $options->{xref_user} -h $options->{xref_host} -D $options->{xref_dbname} -e 'LOAD DATA LOCAL INFILE \"$filename\" INTO TABLE unmapped_object'";
  if (defined $options->{xref_port}) {
    $cmd .= " -P $options->{xref_port}";
  }
  if (defined $options->{xref_pass}) {
    $cmd .= " -p$options->{xref_pass}";
  }
  run($cmd);
  close $fh;
  unlink $filename;

  return;
}

=head2 set_unmapped_reason_id

  Description: Sets unmapped object reason id
  Arg1: Bio::EnsEMBL::Funcgen::UnmappedObject object
  Arg2: hash ref containing:
  - unmapped_object_adaptor: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
  - desc_to_id: hash ref associating an unmapped_reason description to its db id

=cut

sub set_unmapped_reason_id {
  my ($unmapped_object, $options) = @_;
  if ( !ref $unmapped_object || !$unmapped_object->isa('Bio::EnsEMBL::UnmappedObject') ) {
    throw('UnmappedObject must be an Ensembl UnmappedObject, not a ['.ref($unmapped_object).']');
  }

  my $db = $options->{unmapped_object_adaptor}->db();

  if ($unmapped_object->is_stored($db)){
    next;
  }

  my $analysis = $unmapped_object->analysis();
  throw('UnmappedObject must have an analysis object.'.$unmapped_object->analysis."\n") if(!defined($analysis));

  my $analysis_id;
  if($analysis->is_stored($db)) {
    $analysis_id = $analysis->dbID();
  } else {
    $analysis_id = $db->get_AnalysisAdaptor->store($analysis);
  }

  # Check if unmapped reason is cached
  if(!defined($options->{desc_to_id}{$unmapped_object->{'description'}})){
    # Try to store it
    $unmapped_object->{'unmapped_reason_id'} = create_unmapped_reason($db, $unmapped_object);
    $options->{desc_to_id}{$unmapped_object->{'description'}} = $unmapped_object->{'unmapped_reason_id'};
  } else{
    $unmapped_object->{'unmapped_reason_id'} = $options->{desc_to_id}{$unmapped_object->{'description'}};
  }
}

=head2 create_unmapped_reason

  Description: Creates new record in unmapped_reason table
  Arg1: Bio::EnsEMBL::Funcgen::UnmappedObject object
  Arg2: Bio::EnsEMBL::Funcgen::DBSQL::UnmappedObjectAdaptor object
  Returntype: DB ID

=cut

sub create_unmapped_reason {
  my ($db, $unmapped_object) = @_;
  # Insert new reason into unmapped reason table
  my $sql_reason = '
  INSERT INTO
    unmapped_reason
    (summary_description, full_description)
    VALUES
    (?,?)
  ';
  my $sth_reason = $db->dbc->prepare($sql_reason);

  $sth_reason->bind_param(1,$unmapped_object->{'summary'},SQL_VARCHAR);
  $sth_reason->bind_param(2,$unmapped_object->{'description'},SQL_VARCHAR);
  my $id;

  if(! eval{ $sth_reason->execute(); 1 }){
# DBI Trace possible here?
    warning($@); #
    my $msg;
    $msg .= 'INSERT INTO unmapped_reason (summary_description, full_description) VALUES (';
    $msg .=  $unmapped_object->{'summary'} .','. $unmapped_object->{'description'}. ')';
# Temporary fix for naughty cross-dependency regulation code.
    require Data::Dumper;
    warning("Query: \n$msg");
    print STDERR "UnmappedObject: \n";
    print STDERR Dumper $unmapped_object;

    # Search for reason into unmapped_reason table
    my $sql_fetch_reason = '
    SELECT
      unmapped_reason_id
    FROM unmapped_reason
      WHERE full_description = ?
    ';
    my $sth_fetch_reason = $db->prepare($sql_fetch_reason);
    $sth_fetch_reason->execute($unmapped_object->{'description'});

    my $unmapped_reasons = $sth_fetch_reason->fetchrow_arrayref();
    if(! defined($unmapped_reasons)){
      throw($unmapped_object->{'description'}. ' unable to store. Check MySQL schema, maybe PK not big enough?');
    }
    if(scalar @$unmapped_reasons != 1){
      throw('Multiple results for this description');
    }
    $id = $unmapped_reasons->[0];
    $sth_fetch_reason->finish();
  } else{
    $id = $db->dbc->db_handle->last_insert_id(undef, undef, undef, undef);
  }
  $sth_reason->finish();
  return $id;
}

=head2 add_xref

  Description: Creates a hash ref describing an xref and appends it to the array ref (arg6)
  
  If the array has more than 10000 xrefs, they are stored and the array is reset.
  
  Arg1: transcript stable id,
  Arg2: object_id of the Probe/ProbeSet/ProbeFeature
  Arg3: object_type ("Probe", "ProbeFeature" or "ProbeSet")
  Arg4: linkage_annotation string,
  Arg5: transcript version,
  Arg6: xrefs list of already created xrefs
  Arg7: collection of global constants

=cut

sub add_xref {
  my ($transcript_id, $object_id, $object_type, $linkage_annotation, $xrefs, $xref_db, $options) = @_;

  push @$xrefs, [$transcript_id, $linkage_annotation, $object_id, $object_type];
  if (scalar @$xrefs > 10000) {
    store_xrefs($xrefs, $xref_db, $options->{transc_edb_id}, $options->{analysis}, $options->{transcript_xref_id}, $options);
    @$xrefs = ();
  }
  return;
}

# =head2 store_xrefs
# 
#   Description: Loads a bunch of xrefs in a single MySQL command
#   rather than one-by-one.
#   Arg1: hash ref (table) of hash refs (rows), populated by add_xref.
#   Each row contains:
#     * transcript ref
#     * linkage_annotation,
#     * object_id,
#     * object_type ("Probe", "ProbeFeature" or "ProbeSet")
#   Arg2: Bio::EnsEMBL::DBSQL::DBAdaptor object for the external transcript db
#   Arg3: id of the external transcript db in the xref system
#   Arg4: Bio::EnsEMBL::Analysis object
#   Arg5: hash ref linking Bio::EnsEMBL::Transcript objects to xref_id numbers
# 
# =cut
# 
# sub store_xrefs {
#   my ($xrefs, $xref_db, $transc_edb_id, $analysis, $transcript_xref_id, $options) = @_;
# 
#   # Dump table into flat file
#   my ($fh, $filename) = tempfile();
#   for my $xref (@$xrefs) {
#     my ($transcript_id, $linkage_annotation, $object_id, $object_type) = @$xref;
#     if (! defined $transcript_xref_id->{$transcript_id}) {
#       croak("Transcript $transcript_id absent from xref table!\n");
#     }
#     print $fh join("\t", ('\N', $object_id, $object_type, $transcript_xref_id->{$transcript_id}, $linkage_annotation, $analysis->dbID))."\n";
#   }
#   chmod 0644, $filename;
#   # Remember to flush after you're done
#   $fh->autoflush;
# 
#   # Load into database
#   my $cmd = "mysql -u $options->{xref_user} -h $options->{xref_host} -D $options->{xref_dbname} -e 'LOAD DATA LOCAL INFILE \"$filename\" INTO TABLE object_xref'";
#   if (defined $options->{xref_port}) {
#     $cmd .= " -P $options->{xref_port}";
#   }
#   if (defined $options->{xref_pass}) {
#     $cmd .= " -p$options->{xref_pass}";
#   }
#   run($cmd);
#   close $fh;
#   unlink $filename;
#   return;
# }

=head2 run

  Description: Wrapper function for system calls
  Runs command, prints out error in case of failure
  Arg: Command line

=cut

sub run {
  my ($cmd) = @_;
  $Helper->log("Running $cmd\n", 0, 'append_date');
  my $exit_code = system($cmd);
  if ($exit_code != 0) {
    croak("Failure when running command\n$cmd\n")
  }
  return;
}
