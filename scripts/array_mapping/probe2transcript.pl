#
#/usr/bin/env perl

=head1 LICENSE

Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITH$OUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

=head1 CONTACT

Please email comments or questions to the public Ensembl
developers list at <http://lists.ensembl.org/mailman/listinfo/dev>.

Questions may also be sent to the Ensembl help desk at
<http://www.ensembl.org/Help/Contact>.

=head1 NAME

probe2transcript.pl

=head1 SYNOPSIS

This script performs probe(set) to transcript mapping based on a few simple parameters. Overlap analysis 
of ProbeFeatures is performed and annotations are stored as xrefs for individual ProbeFeatures, Probes or 
ProbeSets as a whole. Any probe(set)s which fail the mapping procedure are by default stored in the 
UnmappedObject tables and a logfile is also written.

e.g. perl probe2transcript.pl --species $SPECIES --transcript_dbname $DNADB_NAME --transcript_host $DNADB_HOST --transcript_port $DNADB_PORT --transcript_user $DNADB_USER --xref_host $DB_HOST --xref_dbname $DB_NAME --xref_user $DB_USER --xref_pass $DB_PASS --calculate_utrs --utr_multiplier 1 --arrays HT_MG-430A  -vendor AFFY -format AFFY_UTR


=head1 DESCRIPTION

More wordy description here

promiscuous probes
completed unmapped probes
linked arrays

This is generally executed by the eFG array mapping environment

=head1 OPTIONS

Mandatory
-species    Latin name as used in DB name or meta table e.g. homo_sapiens
-vendor     Array vendor e.g. AFFY, ILLUMINA etc
-format     Array format e.g. AFFY_UTR, AFFY_ST, ILLUMINA_WG. Sets default array configuration
-arrays     List (space separated) of array names.

Array configuration:
-linked_arrays       Boolean(0|1) - For probe(set)s which exist on multiple array e.g. AFFY
-probeset_arrays     Boolean(0|1) - For arrays which contain probesets rather than just single probes
-sense_interrogation Boolean(0|1) - Sets interrogation strand, normally 1 for AFFY but 0 for AFFY_ST i.e. anti-sense

Mapping rules:

-mismatches                  Maximum number of mismatches allowed per probe
-calculate_utrs              This calculates the default unannotated UTR extension defined by
the greater of either the mean or the median of all annotated UTRs
This is overridden by the following extend options
-unannotated_5_utr           Default extension for transcripts with unannotated 5' UTRs
-unannotated_3_utr           Default extension for transcripts with unannotated 3' UTRs
-annotated_5_prime_extend    Default bp extension for all transcripts with annotated 5' UTRs
-annotated_3_prime_extend    Default bp extension for all transcripts with annotated 3' UTRs
-utr_multiplier              Defines UTR extension as multiple of annotated UTR. This is overridden 
if the above options are set.
-max_transcripts             Maximum number of transcripts probe(set) can map to before we call it 
promiscuous, default is 100.
-threshold                   This is the fraction(0-1) of probes within a probeset required to call it 
mapped, default is 0.5


Running modes:

-delete           Delete all pre-existing array xrefs generated by probe2transcript for given arrays
-no_triage        Does not load UnmappedObjects (still writes to log file)
-parallelise      Not yet implemented, will chunk and submit to farm
-clean_up         Not yet implemented, will perform post parallelised run clean up

DB connection parameters, registry will override direct connection:

-reg_verbose    Turns on verbose output when loading the registry

-reg_host
-reg_port
-reg_user
-reg_pass

or

-reg_file

or

-transcript_host          Mandatory
-transcript_user          Mandatory
-transcript_port    
-transcript_pass          Mandatory
-transcript_dbname        Mandatory
-transcript_multi_species
-transcript_species_id

-xref_host          Mandatory
-xref_user          Mandatory
-xref_port
-xref_pass          Mandatory
-xref_dbname        Mandatory
-xref_multi_species
-xref_species_id

-probe_host           Probe parameters
-probe_user           default to xref
-probe_port           DB paramters
-probe_pass           if not
-probe_dbname         specified
-probe_multi_species
-probe_species_id

Testing:

-test_transcripts   Number of transcripts to perform a test run on.
-slice              Name of test slice to perform a test run on 
-transcript         Test transcript stable ID
-no_store           Not yet implemented        

Other options:
-import_edb         Automatically imports the external_db record if not present
-tee                Tees output to STD$OUT
-filename           Sets name to be used in output and logfile, default is xref_dbname_probe2transcript.log|out
-help               Prints this POD documentation and exits


=head1 EXAMPLE


=head1 SEE ALSO

ensembl-funcgen/scripts/environments/arrays.env

=cut

#To do

# 1. Reimpliment validate arrays, see old script?
# 2. Add unannotated UTR clipping dependant on nearest neighbour
# 3. Extend UTRs to default length is they are less than defaults, so long as they don't overlap neighbour, 
#    then use annotated if present or clip to neighbour start/end if not, also accounting for default UTRs 
#    in the neighbour.
# 4. Separate UTR multipliers for 3' and 5'?
# 5. Implement incremental update from list of stable IDs. Consider unmapped probe changes etc. 
# 6. Parallelise by probeset chunks, can't do this by chromosome slices as we need to know genomewide 
#    counts for a given probeset. Calc UTRs then submit chunks jobs to farm
#    Chunk by retrieving all probesets and sorting an array of probeset names, then splice the array 
#    according to the number of chunks. We're still going to have retrieve all the transcripts and retrieve 
#    all probes for each, so we are really not gaining anything!! The only gain we can make is by chunking 
#    by slice, but then we need to know how many times something has mapped. Can we do some clean up afterwards? 
#    Let's add a clean up mode which simply deletes all probe sets which map too many times. We would need to 
#    ignore this threshold as we were mapping!!! So we don't delete and then mess up the counts for post run 
#    clean up.
# 7. There is no reason to have separate probe and xref DBs???
# 8. Validate array format against arrays specified? May want to just use an array format as a template???
# 9. Add mismatch filter for ProbeTranscriptAlign xrefs as match rules can differ between alignment and 
#    annotation
# 10.Handle ProbeAlign mismatch vs overlap mis match. Currently the overlap calculation is naive to the 
#    presence of alignment mis-matches.  Which means there is a possiblity of including probes with a total 
#    sequence mismatch of (align mismatch + overlap mismatch). This has always been the case.
# 11.Move ProbeAlign unmapped object storage to write_output, then this will not get written in test mode and 
#    we won't get duplication should the job fail halfway through. This is because hceck existing only check oxs, not uos.
# 12.Enable probesets to have different sizes on different arrays, see notes in cache_arrays_per_object
# 13.Collect warning into summary repoprt to list at very end.
# 14 Reduce max_transcripts as this is never being hit due to alignment threshold
# 15 Why can't we omit -arrays if we have -format?
# 16 Add UTR only overlap  in range registry.
# 17 Check for ProbeFeature xrefs and UOs in check_existing_and_exit?
# 18 PostAlign/PreXref processing
#    Remove duplicated ProbeFeatures(from ProbeTranscriptAlign) and redirect Xrefs
#    Being careful to make sure cigarlines are valid for both.
#    Remove ProbeTranscriptAlign ProbeFeaturess which have been called promiscuous 
#    by ProbeAlign, and update to promiscuous if sum of ProbeAlign and 
#    ProbeTranscriptAlign features render a Probe promiscuous

#Ensembl Genomes stuff
# TEST Registry usage required as species will come from same DB
# In which case we need to take a species param for each of the transcript, array and xref DBs
# Or can we force delete to be species specific? We would need to do this anyway to support updating of species asynchronously
# We probably need to think about this for the 1st stage too, 
# but will be easy as we just need to dump the correct top level sequence
# Validate species against registry alias and use this to generate species_core_Gene DB rather than ensembl_core_Gene
# patch other efg DBs and alter External parsers accordingly.
# Can't rely on Registry as species aliases may not be present or loaded

# Issues
# Cannot account for running non-linked arrays which may use the same probe/set name.  This may cause failure if the probeset sizes are different. Xrefs and counts should be unaffected as we base these on the probe_set_ids not the names. This is not really an issue as unlinked arrays should not be run together
# Cannot currently handle probesets with different sizes between arrays, defaults to lowest probeset size to be permissive. See todo 12.

use strict;

use Pod::Usage;
use Getopt::Long;
use File::Temp qw/tempfile/;
use DBI qw(:sql_types);

use Bio::EnsEMBL::DBEntry;
use Bio::EnsEMBL::UnmappedObject;
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Mapper::RangeRegistry;
use Bio::EnsEMBL::Registry;
use Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Funcgen::Utils::Helper;
use Bio::EnsEMBL::Funcgen::Utils::EFGUtils qw (median mean get_date);

$| = 1; # auto flush stdout

#Helper params
$main::_log_file = undef;
$main::_tee      = 0;    
our $Helper = new Bio::EnsEMBL::Funcgen::Utils::Helper;
my $debug = 0;

#ARRAY FORMAT CONFIG

my %array_format_config = 
(
  AFFY_UTR => {
    probeset_arrays         => 1,
    linked_arrays      => 0,
    sense_interrogation  => 0,

  },

  AFFY_ST => {
    probeset_arrays         => 1,
    linked_arrays      => 1,
    sense_interrogation  => 1,
  },

  ILLUMINA_WG => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },

  AGILENT => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,                           
  },                                        


  PHALANX => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },

  CODELINK => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },

  LEIDEN => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },

  STEMPLE_LAB_SANGER => {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,
  },

  WUSTL =>  {
    probeset_arrays        => 0,
    linked_arrays     => 1,
    sense_interrogation => 0,                           
  },                        
);

main();

sub main {
  my $options = get_options();

  $Helper->log("Setting global constant variables", 0, 'append_date');
  my ($probe_db, $transcript_db, $xref_db) = @{get_databases($options)};
  $options->{arrays} = get_arrays($xref_db, $options->{vendor}, $options->{array_names});
  my $schema_build = $xref_db->_get_schema_build($transcript_db);
  my $transc_edb_name = "$options->{species}_core_Transcript";
  $options->{transc_edb_id} = get_external_db_id($xref_db, $options->{species}, $transc_edb_name, $schema_build, $options->{import_edb});
  $options->{analysis} = get_or_create_analysis($xref_db);
  my $transcripts = get_transcripts($transcript_db, $options->{test_slice}, $options->{test_transcript_sid});
  $options->{rr} = Bio::EnsEMBL::Mapper::RangeRegistry->new();
  $options->{unmapped_object_adaptor} = $xref_db->get_UnmappedObjectAdaptor();
  $options->{transcript_xref_id} = get_transcript_xref_ids($xref_db, $options->{transc_edb_id});
  # DEBUG: Naughty hidden global
  $options->{desc_to_id} = {};

  check_xrefs($xref_db, $options->{transc_edb_id}, $transcripts, $options->{transcript_xref_id});
  $Helper->log("Cleaning xrefs to avoid duplicate entries", 0, 'append_date');
  if($options->{delete}) {
    delete_existing_xrefs($options);
  } else{
    check_existing_and_exit($xref_db, $options);
  }
  $Helper->log("Checking that all probes link to analyses", 0, 'append_date');
  check_probe_analysis_join($probe_db);
  $Helper->log("Caching arrays per $options->{xref_object}", 0, 'append_date');
  ($options->{arrays_per_object}, $options->{probeset_sizes}, $options->{object_names}) = @{cache_arrays_per_object($probe_db, $options)};
  $Helper->log("Caching transcript / probe feature xrefs", 0, 'append_date');
  $options->{transcripts_per_probefeature} = get_transcripts_per_probefeature($xref_db, $options);
  if($options->{calc_utrs}) {
    $Helper->log('Calculating default UTR lengths from greatest of max median|mean', 0, 'append_date');
    calculate_utrs($options->{unannotated_utrs}, $transcripts);
    $Helper->log('Finished calculating unannotated UTR lengths', 0, 'append_date');
  }

  $Helper->log("Writing extended transcript slices into Bed file", 0, 'append_date');
  my ($fh, $filename) = tempfile(DIR => './');
  write_extended_transcripts_into_file($transcripts, $filename, $options);

  $Helper->log("Dumping probes into Bed file", 0, 'append_date');
  my ($fh2, $filename2) = tempfile(DIR => './');
  dump_probe_features($filename2, $options);

  $Helper->log("Overlapping probe features and transcripts", 0, 'append_date');
  my ($fh3, $filename3) = tempfile(DIR => './');
  run("bedtools intersect -sorted -wa -wb -a $filename -b $filename2 | sort -k4,4 > $filename3");
  close $fh;
  unlink $filename;
  close $fh2;
  unlink $filename2;

# Pesky global variables
  my $xrefs = [];
  my $unmapped_objects = [];
  my $unmapped_counts = {};

  open (my $OUT, ">", "$options->{filename}.out");
  $Helper->log("Performing overlap analysis.", 0, 'append_date');
  my $object_transcript_hits = associate_probes_to_transcripts($transcripts, $fh3, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $OUT);
  unlink $filename3;

  $Helper->log("Logging probesets that don't map to any transcripts", 0, 'append_date');
  log_unmapped_objects($object_transcript_hits, $unmapped_counts, $unmapped_objects, $options, $OUT);
  $Helper->log("Filtering out promiscuous objects", 0 , 'append_date');
  remove_promiscuous_objects($object_transcript_hits, $unmapped_counts, $unmapped_objects, $options, $OUT);
  $Helper->log("Flushing last unmapped probesets", 0 , 'append_date');
  if(scalar @$unmapped_objects) {
    $options->{unmapped_object_adaptor}->store(@$unmapped_objects);
  }

  $Helper->log("Creating final xrefs", 0, 'append_date');
  create_final_xrefs($object_transcript_hits, $xrefs, $xref_db, $options, $OUT);
  $Helper->log("Loading xrefs info DB", 0 , 'append_date');
  if (scalar @$xrefs) {
    store_xrefs($xrefs, $xref_db, $options->{transc_edb_id}, $options->{analysis}, $options->{transcript_xref_id}, $options);
  }
  close ($OUT);

  print_unmapped_counts($unmapped_counts);
  print_xrefs_per_array($options->{xref_object}, $options->{arrays_per_object}, $object_transcript_hits);
  print_most_mapped_transcripts(scalar(@{$transcripts}), $object_transcript_hits, $options->{xref_object});
  print_most_mapped_probes($object_transcript_hits, $options->{xref_object}, $options->{max_transcripts});

  add_mart_displayable_status($options->{array_names}, $options->{vendor}, $xref_db);
  $Helper->log_header("Completed Transcript $options->{xref_object} annotation for @{$options->{array_names}}", 0, 'append_date');
}

# ----------------------------------------------------------------------

sub usage {

  print << "EOF";
Maps probe probes to transcripts.

perl $0 {options}

Options ([..] indicates optional):

READING TRANSCRIPTS:
--transcript_host            The database server to read transcripts from.
[--transcript_port]          The port to use for reading transcripts. Defaults to 3306.
--transcript_user            Database username for reading transcripts.
--transcript_pass            Password for transcript_user, if required.
--transcript_dbname          Database name to read transcripts from.
[--transcript_multi_species] Indicates that the transcript database is multi-species
[--transcript_species_id]    Species ID to use top access multi-species data

READING ARRAYS:
--probe_host            The database server to read probe features from.
[--probe_port]          The port to use for reading probe features. Defaults to 3306.
--probe_user            Database username for reading probe featuress.
--probe_pass            Password for probe_user, if required.
--probe_dbname          Database name to read probe features from.
[--probe_multi_species] Indicates that the transcript database is multi-species
[--probe_species_id]    Species ID to use top access multi-species data

WRITING XREFS:
--xref_host            The database server to write xrefs to.
[--xref_port]          The port to use for writing xrefs.. Defaults to 3306.
--xref_user            Database username for xrefs. Must allow writing.
--xref_pass            Password for xref_user, if required.
--xref_dbname          Database name to write xrefs to.
[--xref_multi_species] Indicates that the transcript database is multi-species
[--xref_species_id]    Species ID to use top access multi-species data

Note that if no probe_host, xref_host etc is specified, probe features will be read from,
and xrefs written to, the database specified by the transcript_* parameters.

Also, triage information will be written to the unmapped_object & unmapped_reason tables
in the xref database, unless the -no_triage option is specified.

GENERAL MAPPING OPTIONS:

[--mismatches]      Allow up to this number of mismatches, inclusive.
Defaults to 1.
[--utr_length]      Search this many bases downstream of the transcript
coding region as well. Defaults to 2000. Specify 'annotated' to use annotated lengths.
[--max_probesets]   Don't store mappings to any 'promiscuous' probesets that map
to more than this number of transcripts. Defaults to 100.
[--arrays]          Mandatory. Space separated list of arrays of same format e.g. AFFY or AFFY_ST etc.
[--threshold]       Fraction of probes per probeset that have to map. Default 0.5 
MISCELLANEOUS:
[--delete]          Delete existing xrefs and object_xrefs, and entries in unmapped_object.
No deletion is done by default.
[--force_delete]    Forces deletion of all unmapped object info even if using a subset of arrays.
[--max_transcripts] Only use this many transcripts. Useful for debugging.
[--no_triage]       Don't write to the unmapped_object/unmapped_reason tables.
[--health_check]    Only do sanity checks, then stop. Useful for capthing errors before nohuping the process proper.
[--help]            This text.
EOF

  exit(0);

}

# ----------------------------------------------------------------------

sub get_options {
  my $options = {};

# Default options
  $options->{reg_verbose} = 0;
  ($options->{transcript_multi_species}, $options->{xref_multi_species}, $options->{probe_multi_species}) = (0,0,0);
  ($options->{transcript_species_id}, $options->{xref_species_id}, $options->{probe_species_id}) = (1,1,1);
  $options->{transcript_port} = 3306; 
  $options->{probe_port} = 3306; 
  $options->{xref_port} = 3306;
  $options->{max_mismatches} = 1;
  $options->{max_transcripts} = 100;
  $options->{mapping_threshold} = 0.5;
  $options->{array_config} = {
    probeset_arrays      => undef,
    linked_arrays        => undef,
    sense_interrogation  => undef,
  };
  $options->{utr_extends} = {
    3 => undef,
    5 => undef,
  };

#Set these to undef so we can allow no estimated UTR
#By setting these to 0 using the params
  $options->{unannotated_utrs} = {
    3 => undef,
    5 => undef,
  };
  $options->{array_names} = [];

  my @tmp_args = @ARGV;

  GetOptions(
    'transcript_host=s'      => \$options->{transcript_host},
  'transcript_user=s'      => \$options->{transcript_user},
  'transcript_port=i'      => \$options->{transcript_port},
  'transcript_pass=s'      => \$options->{transcript_pass},
  'transcript_dbname=s'    => \$options->{transcript_dbname},
  'transcript_species_id=i' => \$options->{transcript_species_id},
  'transcript_multi_species' => \$options->{transcript_multi_species},
  'probe_host=s'           => \$options->{probe_host},
  'probe_user=s'           => \$options->{probe_user},
  'probe_port=i'           => \$options->{probe_port},
  'probe_pass=s'           => \$options->{probe_pass},
  'probe_dbname=s'         => \$options->{probe_dbname},
  'probe_species_id=i' => \$options->{probe_species_id},
  'probe_multi_species' => \$options->{probe_multi_species},
  'xref_host=s'            => \$options->{xref_host},
  'xref_user=s'            => \$options->{xref_user},
  'xref_port=i'            => \$options->{xref_port},
  'xref_pass=s'            => \$options->{xref_pass},
  'xref_dbname=s'          => \$options->{xref_dbname},
  'xref_species_id=i' => \$options->{xref_species_id},
  'xref_multi_species' => \$options->{xref_multi_species},
  'reg_file=s'             => \$options->{reg_file},
  'reg_host=s'             => \$options->{reg_host},
  'reg_user=s'             => \$options->{reg_user},
  'reg_pass=s'             => \$options->{reg_pass},
  'reg_port=i'             => \$options->{reg_port},
  'reg_verbose'            => \$options->{reg_verbose},
  'species=s'              => \$options->{species},
  'vendor=s'               => \$options->{vendor},
  'format=s'               => \$options->{format},
  'mismatches=i'           => \$options->{max_mismatches},
  'annotated_3_prime_extend=s'       => \$options->{utr_extends}->{3},
  'annotated_5_prime_extend=s'       => \$options->{utr_extends}->{5},
  'calculate_utrs'         => \$options->{calc_utrs},
  'unannotated_5_utr=s'    => \$options->{unannotated_utrs}->{5},
  'unannotated_3_utr=s'    => \$options->{unannotated_utrs}->{3},
  'utr_multiplier=s'       => \$options->{utr_multiplier},#Make this for 5 and 3?
  'test_transcripts=i'     => \$options->{test_transcripts},
  'max_transcripts=i'      => \$options->{max_transcripts},
  'threshold=s'            => \$options->{mapping_threshold},
  'arrays=s{,}'            => $options->{array_names}, # this should take 1 or more space separate array names WARNING experimental feature!
  'import_edb'           => \$options->{import_edb},
  'delete'                 => \$options->{delete},
  'no_triage'              => \$options->{no_triage},
  'parallelise'            => \$options->{parallelise},
  'clean_up'               => \$options->{clean_up},
  'linked_arrays=i'          => \$options->{array_config}->{linked_arrays},
  'probeset_arrays=i'        => \$options->{array_config}->{probeset_arrays},
  'sense_interrogation=i'    => \$options->{array_config}->{sense_interrogation},
#Testing
  'slice=s'                => \$options->{test_slice},#Only for testing purposes!
  'transcript=s'           => \$options->{test_transcript_sid},
  'debug'                  => \$options->{debug},
#Helper params
  'tee'                    => \$main::_tee,
  'filename'               => \$main::_log_file,
#add a reduced log to minimize memory usage?
  'help'                   => sub { pos2usage(-exitval => 0, -message => "Params are:\t@tmp_args"); }
  ) or pod2usage(
    -exitval => 1,
    -message => "Params are:\t@tmp_args"
  );

#Set log type so we are no over writing to the same files for different 
#format, or custom formats
  $options->{log_type} = $options->{format} || $$;
  $options->{filename} ||= "$options->{xref_dbname}_$options->{log_type}_probe2transcript";
  $main::_log_file ||=  "./$options->{filename}.log";
  $options->{hostname} = `hostname`;
  chomp($options->{hostname});
  $Helper->log_header('Running on probe2transcript.pl on: '.$options->{hostname}, 0, 'append_date');
  $Helper->log("Params are:\t@tmp_args");

  if (! @{$options->{array_names}}) {
    die("It is not wise to run all available arrays at the same time\nYou must supply a list of array names using -arrays, i.e. for all or a subset of a given array format(e.g. AFFY_UTR, AFFY_ST, ILLUMINA_WG)");
  }

  if (! $options->{vendor}) {
    die ('Must supply a -vendor parameter e.g. AFFY');
  }

  if(defined $options->{format} && ! exists $array_format_config{$options->{format}}) {
    die("-format is not valid:\t$options->{format}\nMust specify valid format e.g. ".join(', ', keys(%array_format_config)).
      "\nOr maybe you want to use -probeset_arrays, -linked_arrays and -sense_interrogation to define the format parameters?\n");
  }

  if(! ($options->{array_config}->{probeset_arrays} && 
        $options->{array_config}->{linked_arrays} && 
        $options->{array_config}->{sense_interrogation})
     && ! $options->{format}) {
    die('You must specify a valid format parameter if you are not using -probeset_arrays, -linked_arrays and -sense_interrogation\n');
  }

  foreach my $key (keys %{$options->{array_config}}) {
    if(! defined $options->{array_config}->{$key}) {
      if(exists $array_format_config{$options->{format}}) {
        $options->{array_config}->{$key} = $array_format_config{$options->{format}}{$key};
      } else{
        die("Cannot find default $options->{key} config for $options->{format} format");
      }
    }
  }

  $options->{xref_object} = ($options->{array_config}{probeset_arrays}) ? 'ProbeSet' : 'Probe';

  if($options->{reg_host} && $options->{reg_file}) {
    die('You have specified confliciting parameters -reg_file -reg_host');
  }

  if(($options->{reg_host} || $options->{reg_file}) && ($options->{probe_dbname} || $options->{xref_dbname} || $options->{transcript_dbname})) {
    die('You have specified conflicting paramters -reg_dbname and -probe_dbname or -transcript_dbname or -xref_dbname');
  }

  if($options->{reg_host} && ! ($options->{reg_user} && $options->{reg_pass})) {
    die('Must provide at least a -reg_user -reg_pass (optional -reg_port -reg_verbose) if loading from db');
  }

  if(! $options->{species}) {
    die("Must provide a -species");
  }

  if(!$options->{reg_file} && !$options->{reg_host}) {
    if (!$options->{transcript_user} || !$options->{transcript_dbname} || !$options->{transcript_host}) {
      die("You must specify a -transcript_user -transcript_dbname -transcript_host\n");
    } 
    if(!$options->{xref_user} || !$options->{xref_dbname} || !$options->{xref_host}) {
      die("You must specify a -xref_user -xref_dbname and -xref_host\n");
    }
  }

  if($options->{test_slice} && $options->{test_transcript_sid}) {
    die('Can only run in one test mode, please specify -slice or -transcript');
  }

  if(defined $options->{utr_extends}->{3} && defined $options->{utr_extends}{5} && $options->{utr_multiplier}) {#Can't have all
    die('You cannot set both -3/5_prime_extend values and a -utr_multiplier');
  }
  elsif(!(defined  $options->{utr_extends}->{3} || defined $options->{utr_extends}{5} || defined $options->{utr_multiplier})) {#Can't have none
    die("You must set some extension rules using  -3/5_prime_extend values and/or -utr_multiplier\n".
      "Set -utr_multiplier to 0 and omit -3/5_prime_extend to run against UTR only\n");
  }
  else{
    $Helper->log("You have specified -utr_multiplier and a -3|5_prime_extend, -3|5_prime_extend will override where appropriate");
  }

#Multiplier needs to be a pisitive real number
  if(defined $options->{utr_multiplier} && $options->{utr_multiplier} !~ /-*[0-9]+[\.0-9]*/) {
    die("-utr_multiplier must be a positive real number:\t$options->{utr_multiplier}");
  }

#Validate extend params
  for my $end ('3', '5') {
    if(defined $options->{utr_extends}->{$end} && $options->{utr_extends}{$end} =~ /\D+/) {
      die("Invalid -${end}_prime_extend parameter(".$options->{utr_extends}{$end}.").  Must be a number(bp)");
    }
  }

#Can't use both default unannotated UTRs and calculate
  if($options->{unannotated_utrs}->{5} && $options->{unannotated_utrs}{3} && $options->{calc_utrs}) {
    die('You cannot set both -unannotated_5/3utr values and -calculate_utrs');
  }

#Validate unannotated defaults
  for my $end ('3', '5') {
    if(defined $options->{unannotated_utrs}->{$end}) {
      if($options->{unannotated_utrs}->{$end} =~ /^\D+$/) {
        die("Invalid -unannotated_${end}_utr parameter(".$options->{unannotated_utrs}{$end}.").  Must be a number(bp)");
      }
      else{
        $Helper->log("Setting ${end} unannotated UTR length to ".$options->{unannotated_utrs}{$end});
      }
    }
    else{
      if(! $options->{calc_utrs}) {
        $Helper->log("Defaulting unannotated ${end} UTR length to 0");
        $options->{unannotated_utrs}->{$end} = 0;
      }
    }
  }

  return $options;
}

# ----------------------------------------------------------------------

sub get_databases {
  my ($options) = @_;
  my ($probe_db, $transcript_db, $xref_db);
  if($options->{reg_file} || $options->{reg_host}) {
    my $reg = 'Bio::EnsEMBL::Registry';
    if($options->{reg_file}) {
      $Helper->log("Loading registry from:\t".$options->{reg_file});
      $reg->load_all($options->{reg_file}, $options->{reg_verbose});
    } else{
      $reg->load_registry_from_db(
        -host    => $options->{reg_host},
        -port    => $options->{reg_port} || 3306,
        -user    => $options->{reg_user},
        -pass    => $options->{reg_pass},
        -verbose => $options->{reg_verbose},
      );
    }        

    $transcript_db = $reg->get_DBAdaptor($options->{species}, 'Core');
    $xref_db       = $reg->get_DBAdaptor($options->{species}, 'Funcgen');
    $probe_db = $xref_db;
  } else{
    $transcript_db = Bio::EnsEMBL::DBSQL::DBAdaptor->new(
      -host    => $options->{transcript_host},
      -port    => $options->{transcript_port},
      -user    => $options->{transcript_user},
      -pass    => $options->{transcript_pass},
      -dbname  => $options->{transcript_dbname},
      -species => $options->{species},
      -multispecies_db => $options->{transcript_multi_species},
      -species_id => $options->{transcript_species_id}
    );

    $xref_db = Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor->new(
      -host => $options->{xref_host},
      -port   => $options->{xref_port},
      -user   => $options->{xref_user},
      -pass   => $options->{xref_pass},
      -dbname => $options->{xref_dbname},
      -species => $options->{species},
      -multispecies_db => $options->{xref_multi_species},
      -species_id => $options->{xref_species_id}
    );

    if ($options->{probe_host} && $options->{probe_dbname} && $options->{probe_user}) {
      $probe_db = Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor->new(
        -host   => $options->{probe_host},
        -port   => $options->{probe_port},
        -user   => $options->{probe_user},
        -pass   => $options->{probe_pass},
        -dbname => $options->{probe_dbname},
        -species => $options->{species},
        -multispecies_db => $options->{probe_multi_species},
        -species_id => $options->{probe_species_id}
      );
    } else{
      $Helper->log("No probe DB params specified, defaulting to xref params");
      $probe_db = $xref_db;
    }
  }

#Test the DBs here before starting
  $transcript_db->dbc->db_handle;
  $xref_db->dbc->db_handle;
  $probe_db->dbc->db_handle;

#Allow automatic reconnection
  $probe_db->dbc->disconnect_if_idle(1);
  $transcript_db->dbc->disconnect_if_idle(1);
  $xref_db->dbc->disconnect_if_idle(1);

  return [$probe_db, $transcript_db, $xref_db];
}

# ----------------------------------------------------------------------
# Params:
# - $xref_db: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
# - $vendor: string
# - $array_names: array ref of strings
#
# Returns: hash ref mapping string names to Bio::EnsEMBL::Funcgen::Array objects
sub get_arrays {
  my ($xref_db, $vendor, $array_names) = @_;
  my $array_format;
  my $aa = $xref_db->get_ArrayAdaptor();
  my %arrays = ();

  foreach my $name(@$array_names) {
    my $array = $aa->fetch_by_name_vendor($name, $vendor);

    if(! $array) {
      die("Could not find $vendor $name array in DB");
    }

    $array_format ||= $array->format();

    if($array_format ne $array_format) {
      die('You must not map arrays of different formats in the same process');
    }

    $arrays{$name} = $array;
  }
  return \%arrays;
}

# ----------------------------------------------------------------------
# Params:
# - xref_db: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
# - species: string name
# - edb_name: MySQL database name 
# - schema build: string
# - import_edb: boolean
#
# Returns: ID number of external id in external_db table (xref system)

sub get_external_db_id {
  my($xref_db, $species, $edb_name, $schema_build, $import_edb) = @_;
#Check for external_db records for species DBs
  my ($transc_edb_display_name, $edb_display);
  $transc_edb_display_name = "EnsemblTranscript";
  $edb_display             = $transc_edb_display_name;

  my $sql = "SELECT external_db_id, db_release from external_db where db_name='$edb_name'";
  my @versions = @{$xref_db->dbc->db_handle->selectall_arrayref($sql)};
  my @tmp;

  foreach my $row(@versions) {
    my ($edb_id, $version) = @$row;
    push @tmp, $version;

    if($schema_build eq $version) { 
      return $edb_id;
    }
  }

  $sql = 'INSERT into external_db(db_name, db_release, status, dbprimary_acc_linkable, priority, db_display_name, type) values('.
  "'${edb_name}', '${schema_build}', 'KNOWNXREF', 1, 5, '$edb_display', 'MISC')";

  if(! $import_edb) {
    die("Could not find current external_db $edb_name $schema_build from available versions:\t @tmp\nMaybe you have mis-spelt the -trans-species or you may need to manually add the external_db to the table and master file:\n\n$sql\n\n");
  } 

  $Helper->log("Importing external_db using: $sql");
  $xref_db->dbc->db_handle->do($sql);
  return $xref_db->last_insert_id();
}

# ----------------------------------------------------------------------
# Params:
# - xref_db: Bio::EnsEMBL::Funcgen::DBSQL::DBAdaptor object
#
# Returns: Bio::EnsEMBL::Analysis object 

sub get_or_create_analysis {
  my ($xref_db) = @_;
  my $analysis_adaptor = $xref_db->get_AnalysisAdaptor();
  my $analysis = $analysis_adaptor->fetch_by_logic_name("probe2transcript");

  if (!$analysis) {
    my $id = $analysis_adaptor->store(new Bio::EnsEMBL::Analysis(
        -logic_name    => 'probe2transcript',
        -program       => 'probe2transcript.pl',
        -description   => 'Microarray probes from manufacturers are aligned to the genome by Ensembl, if the probe sequences are provided. The mapping is a two-step procedure outlined <a href="/info/docs/microarray_probe_set_mapping.html">here</a>.',
        -displayable   => '0')
    );
    $analysis = $analysis_adaptor->fetch_by_logic_name("probe2transcript");
  }
  return $analysis;
}

# ----------------------------------------------------------------------
# Params:
# - transcript_db: Bio::EnsEMBL::DBSQL::DBAdaptor object
# - test_slice: string describing a slice (see Bio::EnsEMBL::DBSQL::SliceAdaptor::fetch_by_name)
# - test_transcript_sid: Ensembl transcript stable identifier
#
# Returns: Array ref of Bio::EnsEMBL::Transcript objects 

sub get_transcripts {
  my ($transcript_db, $test_slice, $test_transcript_sid) = @_;
  my $transcript_adaptor = $transcript_db->get_TranscriptAdaptor();
  my $slice_adaptor = $transcript_db->get_SliceAdaptor();
  my $transcripts;
  if($test_slice) {
    $Helper->log("Running in test mode with slice:\t$test_slice\n".
      "WARNING:\tPromiscuous probesets will not be caught! Calculated UTRs will be wrong!");
#Need to add better text here when we have implemented parallel runs
    my $slice = $slice_adaptor->fetch_by_name($test_slice);
    if (! defined $slice) {
      die("Could not get slice from the DB:\t$slice");
    }
    $transcripts = $transcript_adaptor->fetch_all_by_Slice($slice);
  } elsif($test_transcript_sid) {
    $Helper->log("Running test mode with transcript:\t$test_transcript_sid\n".
      "WARNING:\tPromiscuous probeset will not be caught!\n".
      "WARNING:\t--calc_utrs will not work");

    $transcripts = $transcript_adaptor->fetch_by_stable_id($test_transcript_sid);
  } else{
    $transcripts = $transcript_adaptor->fetch_all();
  }

  if (scalar @$transcripts == 0) {
    die('Could not find any transcripts');
  }
  $Helper->log("Identified ".scalar(@$transcripts)." transcripts for probe mapping");

  my @final = sort {$a->stable_id cmp $b->stable_id} @$transcripts;
  return \@final;
}

# Get internal xref_id for the transcripts in the xref table
sub get_transcript_xref_ids {
  my ($xref_db, $transc_edb_id) = @_;
  my $hash = {};
  my $sql = "SELECT dbprimary_acc, xref_id FROM xref WHERE external_db_id = $transc_edb_id;";
  foreach my $row (@{$xref_db->dbc->db_handle->selectall_arrayref($sql)}) {
    $hash->{$row->[0]} = $row->[1];
  }
  return $hash;
}

sub check_xrefs {
  my ($xref_db, $transc_edb_id, $transcripts, $transcript_xref_id) = @_;
  for my $transcript (@$transcripts) {
    if (! defined $transcript_xref_id->{$transcript->stable_id()}) {
      die("Transcript absent from xref table: ".$transcript->stable_id().", from external db: $transc_edb_id\n");
    }
  }
}


# ----------------------------------------------------------------------
# Delete existing xrefs & object xrefs & unmapped objects. Use user-specified arrays if
# defined, otherwise all arrays.
# Don't restrict to db_version as this would result in DBEntries/UnmappedObjects for old
# releases persisting.


sub delete_existing_xrefs {
  my ($options) = @_;

  my $array_names = '"'.join('", "', @{$options->{array_names}}).'"';
  my $text = "Deleting $options->{species}" . ($array_names) ? "($array_names)" : 'ALL';
  $Helper->log("$text unmapped records and xrefs for probe2transcript...this may take a while");

  my @arrays = values{$options->{array_names}};

  while (my $array = pop @arrays) {
    if (scalar @arrays) {
      $Helper->rollback_ArrayChips($array->get_ArrayChips, 'probe2transcript', undef, undef, 1, 0);
    } else {
      $Helper->rollback_ArrayChips($array->get_ArrayChips, 'probe2transcript', undef, undef, 0, 1);
    }
  }
  return;
}


# ----------------------------------------------------------------------

# Check if there are already xrefs defined, and exit if there are.
# Use user-specified arrays if defined, otherwise all arrays.
# Assumes external_db.dbname == probe_array.name

sub check_existing_and_exit {
  my ($xref_db, $transc_edb_name, $options) = @_;
  $Helper->log_header('Checking existing Xrefs');
  my $probe_join = ($options->{array_config}{probeset_arrays}) ? 'p.probe_set_id' : 'p.probe_id';
  my $xref_sth = $xref_db->dbc()->prepare("SELECT COUNT(*) FROM xref x, object_xref ox, external_db e, probe p, array_chip ac, array a WHERE x.xref_id=ox.xref_id AND e.external_db_id=x.external_db_id AND e.db_name ='$transc_edb_name' and ox.ensembl_object_type='$options->{xref_object}' and ox.ensembl_id=${probe_join} and ox.linkage_annotation!='ProbeTranscriptAlign' and p.array_chip_id=ac.array_chip_id and ac.array_id=a.array_id and a.name=?");

  foreach my $array (@{$options->{array_names}}) {
    $xref_sth->execute($array);
    my $cnt = $xref_sth->fetchrow_array();
    if ($cnt > 0) {
      warn "Array $array already has $cnt xrefs, exiting.\nThere may be other arrays with xrefs. Use -delete to remove them if required.\n";
      exit(1);
    }
  }
  $xref_sth->finish();
}

# ----------------------------------------------------------------------

sub check_probe_analysis_join {
  my ($probe_db) = @_;
  my $sql = 'SELECT distinct pf.analysis_id, a.logic_name from probe_feature pf left join analysis a on pf.analysis_id=a.analysis_id';
  foreach my $record (@{$probe_db->dbc->db_handle->selectall_arrayref($sql)}) {
    my ($anal_id, $lname) = @$record;
    if(! $lname) {
      die("Found probe_feature analysis without a corresponding analysis entry:\t$anal_id");
    }
  }
}

sub get_transcripts_per_probefeature {
  my ($xref_db, $options) = @_;
  my $sql = 'SELECT ensembl_id, dbprimary_acc from object_xref JOIN probe_feature ON probe_feature_id = ensembl_id JOIN probe USING(probe_id) JOIN array_chip USING(array_chip_id) JOIN array USING(array_id) JOIN xref USING(xref_id) WHERE ensembl_object_type = "ProbeFeature" AND array.name in ("'.join('", "', @{$options->{array_names}}).'") AND external_db_id = '. $options->{transc_edb_id};
  my $sth = $xref_db->dbc()->prepare($sql);
  $sth->execute();

  my %transcripts_per_probefeature = ();
  my ($probeset_id, $transcript_sid);
  $sth->bind_columns(\$probeset_id, \$transcript_sid);
  while($sth->fetch()) {
    $transcripts_per_probefeature{$probeset_id} ||= {};
    $transcripts_per_probefeature{$probeset_id}{$transcript_sid} = 1;
  }

  return \%transcripts_per_probefeature;
}

# ----------------------------------------------------------------------

#Change this to mappable xrefs?
#as this can be both probe or probeset?
#Will probes with same name on illumina arrays be the same?
#i.e. Are we collapsing none affy arrays?
#No!
#So we need a flag which turns this off.

sub cache_arrays_per_object {
  my ($probe_db, $options) = @_;

  my $sql;
  if($options->{array_config}{probeset_arrays}) {
    $sql = 'SELECT ps.probe_set_id, ps.name, a.name, count(p.probe_id) FROM probe p, probe_set ps, array a, array_chip ac WHERE a.array_id=ac.array_id and ac.array_chip_id=p.array_chip_id and p.probe_set_id=ps.probe_set_id and a.name in ("'.join('", "', @{$options->{array_names}}).'") GROUP BY p.probe_set_id, a.name';
  }
  else{
    $sql = 'SELECT p.probe_id, GROUP_CONCAT(p.name SEPARATOR "#"), a.name, count(p.probe_id) FROM probe p, array a, array_chip ac WHERE a.array_id=ac.array_id and ac.array_chip_id=p.array_chip_id and a.name in ("'.join('", "', @{$options->{array_names}}).'") GROUP BY p.probe_id, a.name';
  }

  my $sth = $probe_db->dbc()->prepare($sql);
  my ($object_id, $array, $probeset_size, $object_name);
  $sth->execute();
  $sth->bind_columns(\$object_id, \$object_name, \$array, \$probeset_size);

  my %arrays_per_object = ();
  my %probeset_sizes = ();
  my %object_names = ();
  while($sth->fetch()) {
    $arrays_per_object{$object_id} ||= [];
    push @{$arrays_per_object{$object_id}}, $array;
    $object_names{$object_id} ||= [];
    if($options->{array_config}{probeset_arrays}) {
      push @{$object_names{$object_id}}, $object_name;
      if ( defined $probeset_sizes{$object_id} && $probeset_size !=  $probeset_sizes{$object_id}) {
        warn("Found probeset(dbID=$object_id) with differing size between arrays:\ti".join(", ", @{$arrays_per_object{$object_id}})." and $array($probeset_size)\n");
      }
      if ($probeset_sizes{$object_id} < $probeset_size) {
        $probeset_sizes{$object_id} = $probeset_size;
      }
    } else {
      push @{$object_names{$object_id}}, (split/#/, $object_name);
    }
  }
  $sth->finish();

  return [\%arrays_per_object, \%probeset_sizes, \%object_names];
}


# ----------------------------------------------------------------------

sub calculate_utrs {
  my ($unannotated_utrs, $transcripts) = @_;
  my (@five_lengths, @three_lengths);
  my $five_cnt  = 0;
  my $three_cnt = 0;
  my $five_zero_cnt = 0;
  my $three_zero_cnt = 0;

  foreach my $transcript(@$transcripts) {
    if(! defined $unannotated_utrs->{3}) {
      my $three_utr = $transcript->three_prime_utr;

      if (defined $three_utr) {
        $three_cnt++;
        push @three_lengths, $three_utr->length;
      } else{
        $three_zero_cnt++;
      }
    }
    if(! defined $unannotated_utrs->{5}) {
      my $five_utr  = $transcript->five_prime_utr;

      if (defined $five_utr) {
        $five_cnt++;
        push @five_lengths, $five_utr->length;
      } else{
        $five_zero_cnt++;        
      }
    }
  }

  if(! defined $unannotated_utrs->{5}) {
    $Helper->log("Seen $five_cnt 5' UTRs, $five_zero_cnt have length 0");

    if($five_cnt) {
      my ($five_mean, $remainder) = split/\./, mean(\@five_lengths);
      if ($remainder =~ /^[5-9]/) {
        $five_mean++;
      }
      @five_lengths = sort {$a <=> $b} @five_lengths;
      my $five_median = median(\@five_lengths);
      $unannotated_utrs->{5}  = ($five_mean  > $five_median)  ? $five_mean  : $five_median;
      $Helper->log("Calculated default unannotated 5' UTR length:\t".$unannotated_utrs->{5});
    } else{
      die("Found no 5' UTRs, you must specify a -unannotated_5_utr");
    }
  }

  if(! defined $unannotated_utrs->{3}) {
    $Helper->log("Seen $three_cnt 3' UTRs, $three_zero_cnt have length 0");

    if($three_cnt) {
      my ($three_mean, $remainder) = split/\./, mean(\@three_lengths);;
      if ($remainder =~ /^[5-9]/) {
        $three_mean++;
      }
      @three_lengths = sort {$a <=> $b} @three_lengths;
      my $three_median = median(\@three_lengths);
      $unannotated_utrs->{3} = ($three_mean > $three_median) ? $three_mean : $three_median;
      $Helper->log("Calculated default unannotated 3' UTR length:\t".$unannotated_utrs->{3});
    } else{
      die("Found no 3' UTRs, you must specify a -unannotated_3_utr");
    }
  }
}

# ----------------------------------------------------------------------

sub write_extended_transcripts_into_file { 
  my ($transcripts, $filename, $options) = @_;

  my ($fh0, $filename0) = tempfile();
  $options->{flanks} = {};
  $options->{utr_counts} = {};
  $options->{utr_counts}{3} = [];
  $options->{utr_counts}{5} = [];
  foreach my $transcript (@$transcripts) {
    print $fh0 write_extended_transcript($transcript, $options)."\n";
  }

  foreach my $end(5, 3) {
    my $total_length = 0;
    map $total_length += $_, @{$options->{utr_counts}->{$end}};
    my $num_utrs = scalar(@{$options->{utr_counts}->{$end}});
    my $average = ($num_utrs) ? ($total_length/$num_utrs) : 0;
    $Helper->log("Seen $num_utrs $end prime UTRs with and average length of $average");
  }

  run("sort -k1,1 -k2,2n $filename0 > $filename");
  close $fh0;
  unlink $filename0;
}

sub write_extended_transcript { 
  my ($transcript, $options) = @_;
  my $transcript_sid = $transcript->stable_id;

  if ($debug) {
    $Helper->log("\nDEBUG:\tTranscript ".$transcript_sid);
  }

  $options->{flanks}{$transcript_sid} = {
    5 => 0,
    3 => 0,
  };

  foreach my $end('5', '3') {        
    if($options->{utr_extends}{$end} || $options->{utr_multiplier} || $options->{unannotated_utrs}{$end}) {
      my $method = ($end == 5) ? 'five' : 'three';
      $method .= '_prime_utr';
      my $utr = $transcript->$method;

      if(defined $utr) {
        push @{$options->{utr_counts}->{$end}}, $utr->length;
        if(defined $options->{utr_extends}{$end}) {
          $options->{$transcript_sid}{flanks}{$end} = $options->{utr_extends}{$end};
        }
        else{
          $options->{$transcript_sid}{flanks}{$end} = $utr->length * $options->{utr_multiplier};
        }
      } elsif (defined  $options->{unannotated_utrs}{$end}) {
        $options->{$transcript_sid}{flanks}{$end} = $options->{unannotated_utrs}{$end};
      }
    }
  }

  my $new_start;
  my $new_end;
  if ($transcript->strand() >= 0) {
    $new_start = $transcript->seq_region_start - $options->{$transcript_sid}{flanks}{5}; 
    $new_end = $transcript->seq_region_end + $options->{flanks}{3};
  } else {
    $new_start = $transcript->seq_region_start - $options->{$transcript_sid}{flanks}{3}; 
    $new_end = $transcript->seq_region_end + $options->{flanks}{5};
  }

  if ($new_start < 0 ) {
    $new_start = 0;
  }

  return join("\t", ($transcript->seq_region_name, $new_start, $new_end, $transcript->stable_id));
}

# ----------------------------------------------------------------------

sub dump_probe_features {
  my ($filename2, $options) = @_;
  my $sql = 'SELECT seq_region.name, seq_region_start, seq_region_end, seq_region_strand, cigar_line, mismatches, probe_feature_id, probe_id, probe.name, probe_set_id, probe_set.name  FROM probe_feature JOIN probe USING(probe_id) LEFT JOIN probe_set USING(probe_set_id) JOIN array_chip USING(array_chip_id) JOIN array USING(array_id) JOIN seq_region USING(seq_region_id) WHERE array.name IN ("'.join('", "', @{$options->{array_names}})."\") and array.vendor=\"$options->{vendor}\" GROUP BY probe_feature_id, probe_id, probe_set_id ORDER BY seq_region.name, seq_region_start";

  my $cmd = "mysql --quick -NB -u $options->{xref_user} -h $options->{xref_host} -D $options->{xref_dbname} -e '$sql'";
  if (defined $options->{xref_port}) {
    $cmd .= " -P $options->{xref_port}";
  }
  if (defined $options->{xref_pass}) {
    $cmd .= " -p$options->{xref_pass}";
  }

  ## Quick filter for trailing semi-colons in database names
  run("$cmd | sed -e 's/;\$//' > $filename2");
}

# ----------------------------------------------------------------------

sub associate_probes_to_transcripts {
  my ($transcripts, $pf_transc_overlap_fh, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $OUT) = @_;
  my $index = 0;
  my $last_pc = -1;
  my $last_line = undef;
  my $object_transcript_hits = {};

  $Helper->log("% Complete:", 0, 'append_date');
  foreach my $transcript (@$transcripts) {
    my $transcript_feature_info = {};
    if (defined $options->{test_transcripts} && $options->{test_transcripts}-- <= 0) {
      last;
    }
    $last_pc = print_progress($index++, scalar @{$transcripts}, $last_pc);
    $last_line = examine_transcript($transcript, $transcript_feature_info, $pf_transc_overlap_fh, $last_line, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $OUT); 
    compute_hits($transcript, $transcript_feature_info, $object_transcript_hits, $unmapped_objects, $unmapped_counts, $options, $OUT);
  }

  return $object_transcript_hits;
}

sub print_progress {
  my ($index, $total, $last_pc) = @_;
  my $pc = int ((100 * $index) / $total);

  if ($pc > $last_pc) {
    $Helper->log("$pc ", 0, 'append_date');
  }
  return $pc;
}

sub examine_transcript {
  my ($transcript, $transcript_feature_info, $pf_transc_overlap_fh, $last_line, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $OUT) = @_;

  $options->{rr}->flush();
  my @exons     = @{$transcript->get_all_Exons};
  my $num_exons = $#exons;
  my ($first_exon, $last_exon);
  foreach my $e (0..$#exons) {
    $options->{rr}->check_and_register('exonic', $exons[$e]->seq_region_start, $exons[$e]->seq_region_end);
    if ($e == 0) {
      $first_exon = $exons[$e];
    }
    if ($e == $num_exons) {
      $last_exon  = $exons[$e];
    }
  }

  my %exonutrs;
  my $transcript_sid = $transcript->stable_id;
  my $transcript_slice = $transcript->feature_Slice();
  my $slice            = $transcript_slice->expand($options->{$transcript_sid}{flanks}{5}, $options->{$transcript_sid}{flanks}{3});
  if ($transcript->strand == 1) {
    if ($options->{$transcript_sid}{flanks}{3}) {
      $exonutrs{3} = [$last_exon->seq_region_start, $slice->end];
    }
    if ($options->{$transcript_sid}{flanks}{5}) {
      $exonutrs{5} = [$slice->start, $first_exon->seq_region_end];
    }
  } else {
    if ($options->{$transcript_sid}{flanks}{3}) {
      $exonutrs{3} = [$slice->start(), $last_exon->seq_region_end];
    }
    if ($options->{$transcript_sid}{flanks}{5}) {
      $exonutrs{5} = [$first_exon->seq_region_start, $slice->end];
    }
  }

  foreach my $end('3', '5') {
    if ($options->{$transcript_sid}{flanks}{$end}) {
      $options->{rr}->check_and_register("${end}_exonutr", @{$exonutrs{$end}});
    }
  }

  my $line = $last_line;
  my $overran = 0;
  my $count = 0;
  if (defined $line) {
    chomp $line;
    my ($tx_chr, $tx_start, $tx_end, $transcript_sid, $chr, $start, $end, $strand, $cigar, $mismatches, $feature_id, $probe_id, $probe_name, $probeset_id, $probeset_name) = split "\t", $line;
    if ($transcript_sid gt $transcript->stable_id()) {
      $overran = 1;
    }
    if ($transcript_sid eq $transcript->stable_id()) {
      examine_probefeature($transcript, $feature_id, $probe_id, $probe_name, $probeset_id, $probeset_name, $start, $end, $strand, $cigar, $mismatches, $transcript_feature_info, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $OUT);
      $count++;
    }
  }

  while (!$overran && defined ($line = <$pf_transc_overlap_fh>)) {
    chomp $line;
    my ($tx_chr, $tx_start, $tx_end, $transcript_sid, $chr, $start, $end, $strand, $cigar, $mismatches, $feature_id, $probe_id, $probe_name, $probeset_id, $probeset_name) = split "\t", $line;
    if ($transcript_sid gt $transcript->stable_id()) {
      last;
    }
    if ($transcript_sid eq $transcript->stable_id()) {
      examine_probefeature($transcript, $feature_id, $probe_id, $probe_name, $probeset_id, $probeset_name, $start, $end, $strand, $cigar, $mismatches, $transcript_feature_info, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $OUT);
      $count++;
    }
  }

  if ($debug) {
    $Helper->log("DEBUG:\tProbeFeatures $count for ".join("\t", (map $_->name, values(%{$options->{arrays}}))));
  }

  print $OUT "\n";
  return $line;
}

sub examine_probefeature {
  my ($transcript, $feature_id, $probe_id, $probe_name, $probeset_id, $probeset_name, $start, $end, $strand, $cigar_line, $mismatch_count, $transcript_feature_info,$unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $OUT) = @_;
  my $transcript_sid = $transcript->stable_id();
  my $transcript_version     = $transcript->version;
  my $log_name;

  if($options->{array_config}{probeset_arrays}) {
    $log_name       = $transcript_sid."\t(${probeset_name})\t${probe_id}";
  } else{
    $log_name       = $transcript_sid."\t(".join(',', @{$options->{object_names}->{$probe_id}}).")\t${probe_id}";
  }

  if($options->{array_config}{sense_interrogation}) {
    if($transcript->seq_region_strand == $strand) {
      print $OUT "Unmapped sense ".$log_name."\n";
      next;
    }
  } elsif ($transcript->seq_region_strand != $strand) {
    print $OUT "Unmapped anti-sense ".$log_name."\n";
    next;
  }

  my $mm_link_txt = '';
  my $mismatches = 0;
  if ($mismatch_count) {
    $mismatches = 1;
    $mm_link_txt = ' ('. $mismatch_count.' bp mismatch)';
  }

  if($cigar_line =~ /D/) {
    record_gapped_probefeature($feature_id, $probe_id, $probeset_id, $transcript, $transcript_feature_info, $mm_link_txt, $mismatches, $log_name, $unmapped_counts, $unmapped_objects, $options, $OUT);
  } else {
    record_aligned_probefeature($feature_id, $probe_id, $probeset_id, $start, $end, $cigar_line, $mismatch_count, $transcript_feature_info, $transcript, $mm_link_txt, $mismatches, $log_name, $cigar_line, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $OUT);
  }
}

sub record_gapped_probefeature {
  my ($feature_id, $probe_id, $probeset_id, $transcript, $transcript_feature_info, $mm_link_txt, $mismatches, $log_name, $unmapped_counts, $unmapped_objects, $options, $OUT) = @_;
  my $transcript_sid = $transcript->stable_id();

  if(exists $options->{transcripts_per_probefeature}{$feature_id}{$transcript_sid}) {
    if ($options->{array_config}{probeset_arrays}) {
      $transcript_feature_info->{$probeset_id}{$probe_id} ||= [0, 0];
      $transcript_feature_info->{$probeset_id}{$probe_id}->[0]++;
      $transcript_feature_info->{$probeset_id}{$probe_id}->[1] += $mismatches;
    } else {
      $transcript_feature_info->{$probe_id} ||= [];
      push @{$transcript_feature_info->{$probe_id}}, ["exon-exon match${mm_link_txt}", $mismatches];
    }
  } else {
    print $OUT "Unmapped Gapped ProbeFeature ".$log_name."\n";
    cache_and_load_unmapped_objects(
      $options, 
      $unmapped_counts, 
      $unmapped_objects, 
      $transcript_sid, 
      'ProbeFeature', 
      $feature_id,  
      "Unmapped Gapped ProbeFeature", 
      "Gapped ProbeFeature did not match transcript structure"
    );
  }
}

sub record_aligned_probefeature {
  my ($feature_id, $probe_id, $probeset_id, $start, $end, $cigar_line, $mismatch_count, $transcript_feature_info, $transcript, $mm_link_txt, $mismatches, $log_name, $cigar_line, $unmapped_counts, $unmapped_objects, $xrefs, $xref_db, $options, $OUT) = @_;
  my $five_mismatch  = 0;
  my $three_mismatch = 0;
  my $feature_start  = $start;
  my $feature_end    = $end;

  if($cigar_line =~ /(^[0-9]+)m/) {
    $five_mismatch = $1;
    $feature_start += $five_mismatch;
  }

  if($cigar_line =~ /([0-9]+$)m/) {
    $three_mismatch = $1;
    $feature_end -= $three_mismatch;
  }

  my $min_overlap  = ($end - $start + 1 - $options->{max_mismatches} + ($mismatch_count - $five_mismatch - $three_mismatch));
  my $exon_overlap = $options->{rr}->overlap_size('exonic', $feature_start, $feature_end);
  my $flank_end     = 0;
  my $flank_overlap = 0;

  foreach my $end ('3', '5') {
    if ($options->{$transcript->stable_id}{flanks}{$end}) {
      $flank_overlap = $options->{rr}->overlap_size("${end}_exonutr", $start, $end);
    }
    if ($flank_overlap) {
      $flank_end = $end;
      last;
    }
  }

  if (($exon_overlap >= $min_overlap) ||
    ($flank_overlap >= $min_overlap)) {
    my $linkage_annotation;

    if ($exon_overlap && $flank_overlap) {
      $linkage_annotation = "exon/${flank_end}' flank boundary${mm_link_txt}";
    } elsif ($exon_overlap) {
      $linkage_annotation = "exon${mm_link_txt}";
    } else {                                #only flank over lap
      $linkage_annotation = "${flank_end}' flank${mm_link_txt}";
    }

    if ($options->{array_config}{probeset_arrays}) {
      $transcript_feature_info->{$probeset_id}{$probe_id} ||= [0, 0];
      $transcript_feature_info->{$probeset_id}{$probe_id}->[0]++;
      $transcript_feature_info->{$probeset_id}{$probe_id}->[1] += $mismatches;
    } else {
      $transcript_feature_info->{$probe_id} ||= [];
      push @{$transcript_feature_info->{$probe_id}}, [$linkage_annotation, $mismatches];
    }
    add_xref($transcript->stable_id, $feature_id, 'ProbeFeature', $linkage_annotation, $xrefs, $xref_db, $options);
  } else { 
    my ($summary, $region);

    if (!( $exon_overlap || $flank_overlap)) {
      $summary = 'intronic';
      $region  = 'intronic region';
    } elsif ($exon_overlap) {
      if (! $flank_overlap) {
        $summary = 'exon boundary';
        $region  = $summary;
      } else {
        $summary = "${flank_end}' flank boundary";
        $region  = $summary;
      }
    } else {        
      $summary = "${flank_end}' flank boundary";
      $region  = $summary;
    }
    print $OUT "Unmapped $summary ".$log_name."\n";
    cache_and_load_unmapped_objects(
      $options, 
      $unmapped_counts, 
      $unmapped_objects, 
      $transcript->stable_id, 
      'ProbeFeature',  
      $feature_id, 
      "Unmapped $summary", 
      "Probe mapped to $region of transcript"
    );
  }
}

# ----------------------------------------------------------------------
# Converts hash ref linking objects to hits into a more conveninent 
# array ref for later stream processing
#
# Params:
# - transcript: Bio::EnsEMBL::Transcript object
# - transcript_feature_info: hash ref linking objects to hits
# - object_transcript_hits: hash ref of hash refs linking 
# - probeset_arrays: boolean determining whether the arrays are
# object_id x Bio::EnsEMBL::Transcript object => array ref
# - unmapped_counts: hash ref with stats on unmapped objects
# - unmapped_objects: array ref with list of unmapped objects
#  made up of probesets
# - options: hash ref of global constants
# - OUT: File handle for detailed output
#
# Action: Augments the content of object_transcript_hits

sub compute_hits {
  my ($transcript, $transcript_feature_info, $object_transcript_hits, $unmapped_objects, $unmapped_counts, $options, $OUT) = @_;

  foreach my $object_id (keys %$transcript_feature_info) {
    my $hits;
    if($options->{array_config}{probeset_arrays}) {
      $hits = scalar(keys %{$transcript_feature_info->{$object_id}});
    } else{
      $hits = scalar(@{$transcript_feature_info->{$object_id}});
    }

    my $probeset_size = $options->{probeset_sizes}{$object_id};

    if (($options->{xref_object} eq 'ProbeSet' && ($hits / $probeset_size) >= $options->{mapping_threshold}) 
          || ($hits && ($options->{xref_object} eq 'Probe'))) {
      my $num_mismatch_hits = 0;
      if($options->{array_config}{probeset_arrays}) {
        map {$num_mismatch_hits += 1 if $_->[1] == $_->[0]}  values %{$transcript_feature_info->{$object_id}};
      } else{
        map {$num_mismatch_hits += 1 if $_->[1] } @{$transcript_feature_info->{$object_id}};
      }

      $object_transcript_hits->{$object_id}{$transcript->stable_id} = [$hits, $num_mismatch_hits];
    } else {
      my $id_names = $object_id.'('.join(',', @{$options->{object_names}{$object_id}}).')';
      print $OUT "$id_names\t".$transcript->stable_id."\tinsufficient\t$hits/$probeset_size in ProbeSet\n";
      cache_and_load_unmapped_objects(
        $options, 
        $unmapped_counts, 
        $unmapped_objects, 
        $transcript->stable_id, 
        'ProbeSet',  
        $object_id,  
        "Insufficient hits", 
        "Insufficient number of hits $hits/$probeset_size in ProbeSet"
      );
    }
  }
}

# ----------------------------------------------------------------------
# Stores all objects with no assocation to a transcript into the unmapped
# table
#
# Params:
# - object_transcript_hits: hash ref of hash refs linking 
# object_id x Bio::EnsEMBL::Transcript object => array ref
# - unmapped_counts: hash ref with stats on unmapped objects
# - unmapped_objects: array ref with list of unmapped objects
# - options: hash ref of global constants
# - OUT: File handle for detailed output

sub log_unmapped_objects {
  my ($object_transcript_hits, $unmapped_counts, $unmapped_objects, $options, $OUT) = @_;

  if($options->{test_slice} || $options->{test_transcript_sid}) {
    my $tmp = $options->{test_slice} || $options->{test_transcript_sid};
    $Helper->log("Skipping log_unmapped_objects as we are running on a test on:\t${tmp}");
    return;
  }

  my ($object_id, $object_name);

  foreach my $object_id (keys %{$options->{arrays_per_object}}) {
    if (!exists $object_transcript_hits->{$object_id}) {
      my $names = join(',', @{$options->{object_names}{$object_id}});
      print $OUT "$options->{xref_object} $object_id($names)\tNo transcript mappings\n";
      cache_and_load_unmapped_objects(
        $options, 
        $unmapped_counts, 
        $unmapped_objects, 
        'NO_TRANSCRIPT_MAPPINGS', 
        $options->{xref_object}, 
        $object_id, 
        'No transcript mappings', 
        $options->{xref_object}.' did not map to any transcripts'
      ); 
    }
  }
}

# ----------------------------------------------------------------------
# Removes objects with too many hits from the list of candidate object+transcript hits 
#
# Params:
# - transcripts_per_object: hash ref linking objects to a count
# - object_transcript_hits: list of candidate xref hits
# - unmapped_counts: hash ref with stats on unmapped objects
# - unmapped_objects: array ref with list of unmapped objects
# - options: hash ref with constant variables, in particular:
#   * max_transcripts: integer cutoff
#   * object_names: hash ref linking object_id => object name
#   * probeset_sizes: hash ref linking object_id => integer size
#   * xref_object: "Probe" or "ProbeSet"
# - OUT: File handle for detailed output
#
# Returns: array ref of filtered hits

sub remove_promiscuous_objects {
  my ($object_transcript_hits, $unmapped_counts, $unmapped_objects, $options, $OUT) = @_;

  foreach my $object_id (keys %$object_transcript_hits) {
    my $object_transcript_count = scalar keys %{$object_transcript_hits->{$object_id}};
    if ($object_transcript_count > $options->{max_transcripts}) {
      foreach my $transcript_id (keys %{$object_transcript_hits->{$object_id}}) {
        my $id_names = $object_id.'('.join(',', @{$options->{object_names}{$object_id}}).')';
        my $probeset_size = $options->{probeset_sizes}->{$object_id};
        my $hits = $object_transcript_hits->{$object_id}{$transcript_id}{0};
        print $OUT "$id_names\t$transcript_id\tpromiscuous\t$hits/$probeset_size\tCurrentTranscripts".$object_transcript_count."\n";
        cache_and_load_unmapped_objects(
          $options, 
          $unmapped_counts, 
          $unmapped_objects, 
          $transcript_id, 
          'ProbeSet',  
          $object_id,  
          "Promiscuous $options->{xref_object}", 
          "$options->{xref_object} maps to $object_transcript_count transcripts (max 100)."
        );
        delete $object_transcript_hits->{$object_id};
      }
    } 
  }
}

# ----------------------------------------------------------------------
# Transforms the filtered list of object+transcript hits into xrefs and
# loads those
#
# Params:
# - object_transcript_hits: hash ref of hash refs linking 
# object_id x Bio::EnsEMBL::Transcript object => array ref
# - xrefs: temporary array storage for xref objects about to be loaded
# - options: hash ref with constant variables, in particular:
#   * object_names: hash ref linking object_id => object name
#   * probeset_sizes: hash ref linking object_id => integer size
#   * xref_object: "Probe" or "ProbeSet"
sub create_final_xrefs {
  my ($object_transcript_hits, $xrefs, $xref_db, $options, $OUT) = @_;

  foreach my $object_id (keys %$object_transcript_hits) {
    foreach my $transcript_id (keys %{$object_transcript_hits->{$object_id}}) {
      my ($hits, $num_mismatch_hits) = @{$object_transcript_hits->{$object_id}{$transcript_id}};
      my $id_names = $object_id.'('.join(',', @{$options->{object_names}{$object_id}}).')';

      my $linkage_annotation;
      if($options->{xref_object} eq 'ProbeSet') {
        my $probeset_size = $options->{probeset_sizes}->{$object_id};
        $linkage_annotation = "${hits}/${probeset_size} in probeset";
        if ($num_mismatch_hits) {
          if ($num_mismatch_hits == 1) {
            $linkage_annotation .= "(with 1 mismatched probe)";
          } else{
            $linkage_annotation .= "(with $num_mismatch_hits mismatched probes)";
          }
        }
      } elsif($hits > 1) {
        $linkage_annotation = "Matches $hits times";
        if ($num_mismatch_hits) {
          $linkage_annotation .= " ($num_mismatch_hits times with mismatches)";
        }
      } else{
        $linkage_annotation = 'Matches '.$hits - $num_mismatch_hits;
      }

      my $other_hits = (scalar keys %{$object_transcript_hits->{$object_id}}) - 1;
      if($other_hits >= 1) {
        my $plural = ($other_hits == 1) ? '' : 's';
        $linkage_annotation .= ". Matches $other_hits other transcript${plural}";
      }
      else{
        $linkage_annotation .= ". Maps uniquely to this transcript";
      }

      add_xref($transcript_id, $object_id, $options->{xref_object}, $linkage_annotation, $xrefs, $xref_db, $options);
      print $OUT "$id_names\t$transcript_id\tmapped\t$hits/$options->{probeset_size}{$object_id}\n";
    }
  }
}

# ----------------------------------------------------------------------
# All the following functions display various stats on the whole process

# ----------------------------------------------------------------------
# Params:
# - unmapped_counts: hash ref of hash refs linking:
# object_type x object name => integer count
sub print_unmapped_counts {
  my ($unmapped_counts) = @_;
  my $uo_string;

  foreach my $obj_type(keys %$unmapped_counts) {
    if ($obj_type eq 'Total') {
      next;
    }

    foreach my $uo_label(keys %{$unmapped_counts->{$obj_type}}) {
      $uo_string .= "\t\t\t\t${obj_type}\t${uo_label}\t".$unmapped_counts->{$obj_type}->{$uo_label}."\n";
    }
  }
  $uo_string .= "\t\t\t\tTotal\t".$unmapped_counts->{Total}."\n";
  $Helper->log("UnmappedObjects loaded:\n$uo_string");
}

# ----------------------------------------------------------------------
# Params:
# - xref_object: "Probe" or "ProbeSet"
# - arrays_per_object: hash ref linking object_id => array name
# - object_transcript_hits: hash ref of hash refs linking 
# object_id x Bio::EnsEMBL::Transcript object => array ref
sub print_xrefs_per_array {
  my ($xref_object, $arrays_per_object, $object_transcript_hits) = @_;
  my $count = 0;

  $Helper->log("Counting xrefs");

  my %objects_per_array = ();
  my %total = ();
  my %covered_objects = ();
  foreach my $object_id (keys %$object_transcript_hits) {
    foreach my $array (@{$arrays_per_object->{$object_id}}) {
      $count++;
      $objects_per_array{$array} ||= 0;
      $objects_per_array{$array}++;
      $total{$array}++;
      $covered_objects{$array} ||= {};
      $covered_objects{$array}{$object_id} = undef;
    }
  }

  $Helper->log("Found ".scalar(keys(%$object_transcript_hits))." hits");
  $Helper->log("Total updates: $count");

  foreach my $aname(keys %total) {
    $Helper->log("$aname distinct $xref_object xrefs mapped(total xrefs):\t". 
      scalar(keys(%{$covered_objects{$aname}}))."/$objects_per_array{$aname}($total{$aname})");
  }
}

# ----------------------------------------------------------------------
# Params:
# - Total: number of transcripts 
# - object_transcript_hits: hash ref of hash refs linking 
# object_id x Bio::EnsEMBL::Transcript object => array ref
# - xref_object: "Probe" or "ProbeSet"
sub print_most_mapped_transcripts {
  my ($total, $object_transcript_hits, $xref_object) = @_;
  my %transcript_xref_counts = ();

  foreach my $object_id (keys %$object_transcript_hits) {
    foreach my $transcript_id (keys %{$object_transcript_hits->{$object_id}}) {
      $transcript_xref_counts{$transcript_id}++;
    }
  }

  $Helper->log('Mapped '. scalar(keys(%transcript_xref_counts))."/$total transcripts ", 0, 'append_date');

#sort keys with respect to values.
  $Helper->log_header("Top 5 most mapped transcripts:");
  my @tids = sort { $transcript_xref_counts{$b} <=>  $transcript_xref_counts{$a} } keys %transcript_xref_counts;

  for my $i(0..4) {
    $Helper->log("$tids[$i] mapped $transcript_xref_counts{$tids[$i]} times");
  }
}

# ----------------------------------------------------------------------
# Params:
# - object_transcript_hits: hash ref of hash refs linking 
# object_id x Bio::EnsEMBL::Transcript object => array ref
# - xref_object: "Probe" or "ProbeSet"
sub print_most_mapped_probes {
  my ($object_transcript_hits, $xref_object) = @_;
  my %transcripts_per_object = ();

  foreach my $object_id (keys %$object_transcript_hits) {
    $transcripts_per_object{$object_id} = scalar keys %{$object_transcript_hits->{$object_id}};
  }

  $Helper->log_header("Top 5 most mapped ${xref_object}s (no promiscuous):");
  my @xo_ids = sort { $transcripts_per_object{$b} <=>  $transcripts_per_object{$a} } keys %transcripts_per_object;
  my @xo_counts = sort { $b <=> $a } values %transcripts_per_object;
  my $num_ids = scalar(@xo_counts);

  for my $i(0..4) {
    $Helper->log("dbid $xo_ids[$i] mapped $xo_counts[$i] times");
  }
}

# ----------------------------------------------------------------------
# BioMart voodoo, don't ask me what this means

sub add_mart_displayable_status {
  my ($array_names, $vendor, $xref_db) = @_;
  my $sql='INSERT IGNORE into status select a.array_id, "array", sn.status_name_id from array a, status_name sn where a.name in ("'.
  join('", "', @$array_names)."\") and a.vendor='$vendor' and sn.name in ('MART_DISPLAYABLE')";
  $Helper->log_header('Adding MART_DISPLAYABLE status entries');
  $xref_db->dbc->do($sql);
}

# ----------------------------------------------------------------------
# Stores an objects into the unmapped_object table, with some caching
#
# Params:
# - options: hash ref of global constants
# - unmapped_counts: hash ref with stats on unmapped objects
# - unmapped_objects: array ref with list of unmapped objects
# - identifier: stable id to potential hit
# - object_type: Probe, ProbeSet or ProbeFeature
# - object_id: Ensembl ID of the object
# - summary: short string
# - description: longer string

sub cache_and_load_unmapped_objects {
  my ($options, $unmapped_counts, $unmapped_objects, $identifier, $object_type, $object_id, $summary, $description) = @_;
  if (! $options->{no_triage}) {
    my $um_obj = new Bio::EnsEMBL::UnmappedObject
    (
      -type       => 'probe2transcript',
      -analysis   => $options->{analysis},
      -identifier => $identifier,
      -summary    => $summary,
      -full_desc  => $description,
      -ensembl_object_type => $object_type,
      -ensembl_id => $object_id,
      -external_db_id => $options->{transc_edb_id},
    );
    $unmapped_counts->{$um_obj->ensembl_object_type}{$um_obj->summary} ||= 0;  
    $unmapped_counts->{$um_obj->ensembl_object_type}{$um_obj->summary}++;
    $unmapped_counts->{Total}++;
    push @{$unmapped_objects}, $um_obj;
    if(scalar(@{$unmapped_objects}) > 10000) {
      store_unmapped_objects($unmapped_objects, $options);
      @{$unmapped_objects} = ();
    }
  }
}

sub store_unmapped_objects {
  my ($unmapped_objects, $options) = @_;

  if( scalar(@$unmapped_objects) == 0 ) {
    throw("Must call store with list of UnmappedObjects");
  }

  my $db = $options->{unmapped_object_adaptor}->db();
  my $analysis_adaptor = $db->get_AnalysisAdaptor();

  my $sth_reason = $options->{unmapped_object_adaptor}->prepare
    ("INSERT INTO unmapped_reason (summary_description, full_description)".
    " VALUES (?,?)");

  my $sth_fetch_reason =
  $options->{unmapped_object_adaptor}->prepare(
    "SELECT 
    unmapped_reason_id
    FROM 
    unmapped_reason
    WHERE
    full_description = ? 
    " );

  foreach my $unmapped_object ( @$unmapped_objects ) {
    if( !ref $unmapped_object || !$unmapped_object->isa("Bio::EnsEMBL::UnmappedObject") ) {
      throw("UnmappedObject must be an Ensembl UnmappedObject, " .
      "not a [".ref($unmapped_object)."]");
    }
      if($unmapped_object->is_stored($db)){
      next;
    } 

    my $analysis = $unmapped_object->analysis();
    throw("UnmappedObject must have an analysis object.".$unmapped_object->analysis."\n") if(!defined($analysis));

    my $analysis_id;
    if($analysis->is_stored($db)) {
      $analysis_id = $analysis->dbID();
    } else {
      $analysis_id = $db->get_AnalysisAdaptor->store($analysis);
    }

# Check if unmapped reason is cached
# Check if it has been added since the cache was created
# Try to store it

    if(!defined($options->{desc_to_id}{$unmapped_object->{'description'}})){
      $sth_reason->bind_param(1,$unmapped_object->{'summary'},SQL_VARCHAR);
      $sth_reason->bind_param(2,$unmapped_object->{'description'},SQL_VARCHAR);

      if(! eval{ $sth_reason->execute(); 1 }){    
# DBI Trace possible here?
        warning($@); #
        my $msg;
        $msg .= "INSERT INTO unmapped_reason (summary_description, full_description) VALUES (";
        $msg .=  $unmapped_object->{'summary'} .','. $unmapped_object->{'description'}. ')';
# Temporary fix for naughty cross-dependency regulation code.
        use Data::Dumper;
        warning("Query: \n$msg");
        print STDERR "UnmappedObject: \n";
        print STDERR Dumper $unmapped_object;

        $sth_fetch_reason->execute($unmapped_object->{'description'});

        my $unmapped_reasons = $sth_fetch_reason->fetchrow_arrayref();
        if(! defined($unmapped_reasons)){
          my $msg = $unmapped_object->{'description'}. " unable to store. Check MySQL schema, maybe PK not big enough?";
          throw($msg);
        }
        if(scalar @$unmapped_reasons != 1){
          throw("Multiple results for this description");
        }
        $unmapped_object->{'unmapped_reason_id'} = $unmapped_reasons->[0];

      } else{
        $unmapped_object->{'unmapped_reason_id'} = $options->{unmapped_object_adaptor}->last_insert_id;
      }
      $options->{desc_to_id}{$unmapped_object->{'description'}} = $unmapped_object->{'unmapped_reason_id'};
    } else{
      $unmapped_object->{'unmapped_reason_id'} = $options->{desc_to_id}{$unmapped_object->{'description'}};
    }
  }
  $sth_reason->finish();      

  my ($fh, $filename) = tempfile();
  foreach my $unmapped_object ( @$unmapped_objects ) {
    print $fh join("\t", ['\N', $unmapped_object->{'type'}, $unmapped_object->analysis->dbID, $unmapped_object->{'external_db_id'}, $unmapped_object->{'identifier'}, $unmapped_object->{'unmapped_reason_id'}, $unmapped_object->{'query_score'}, $unmapped_object->{'target_score'}, $unmapped_object->{'ensembl_id'}, $unmapped_object->{'ensembl_object_type'}, '\N'])."\n";
  }
  chmod 0644, $filename;
  $fh->autoflush;
  my $cmd = "mysql -u $options->{xref_user} -h $options->{xref_host} -D $options->{xref_dbname} -e 'LOAD DATA LOCAL INFILE \"$filename\" INTO TABLE unmapped_object'";
  if (defined $options->{xref_port}) {
    $cmd .= " -P $options->{xref_port}";
  }
  if (defined $options->{xref_pass}) {
    $cmd .= " -p$options->{xref_pass}";
  }
  run($cmd);
  close $fh;
  unlink $filename;
}

# ----------------------------------------------------------------------
# Creates a hash ref describing an xref and appends it to the array ref
#
# Parameters:
# - transcript stable id, 
# - object_id of the Probe/ProbeSet/ProbeFeature
# - object_type ("Probe", "ProbeFeature" or "ProbeSet")
# - linkage_annotation string,
# - transcript version,
# - xrefs list of already created xrefs
# - options: collection of global constants

sub add_xref {
  my ($transcript_id, $object_id, $object_type, $linkage_annotation, $xrefs, $xref_db, $options) = @_;

  push @$xrefs, [$transcript_id, $linkage_annotation, $object_id, $object_type];
  if (scalar @$xrefs > 10000) {
    store_xrefs($xrefs, $xref_db, $options->{transc_edb_id}, $options->{analysis}, $options->{transcript_xref_id}, $options);
    @$xrefs = ();
  }
}

# ----------------------------------------------------------------------
# Loads a bunch of xrefs in a single MySQL commands
# rather than one-by-one.
#
# Parameters:
#  - xrefs: hash ref (table) of hash refs (rows), populated by add_xref.
#  Each row contains:
#    * transcript ref 
#    * linkage_annotation, 
#    * object_id, 
#    * object_type ("Probe", "ProbeFeature" or "ProbeSet")
# - xref_db: Bio::EnsEMBL::DBSQL::DBAdaptor object for the external transcript db
# - transc_edb_id: id of the external transcript db in the xref system
# - analysis: Bio::EnsEMBL::Analysis object
# - transcript_sref_id: hash ref linking Bio::EnsEMBL::Transcript objects to xref_id numbers

sub store_xrefs {
  my ($xrefs, $xref_db, $transc_edb_id, $analysis, $transcript_xref_id, $options) = @_;
  my ($fh, $filename) = tempfile();
  for my $xref (@$xrefs) {
    my ($transcript_id, $linkage_annotation, $object_id, $object_type) = @$xref;
    if (! defined $transcript_xref_id->{$transcript_id}) {
      die("Transcript $transcript_id absent from xref table!\n");
    }
    print $fh join("\t", ('\N', $object_id, $object_type, $transcript_xref_id->{$transcript_id}, $linkage_annotation, $analysis->dbID))."\n";
  }
  chmod 0644, $filename;
  $fh->autoflush;
  my $cmd = "mysql -u $options->{xref_user} -h $options->{xref_host} -D $options->{xref_dbname} -e 'LOAD DATA LOCAL INFILE \"$filename\" INTO TABLE object_xref'";
  if (defined $options->{xref_port}) {
    $cmd .= " -P $options->{xref_port}";
  }
  if (defined $options->{xref_pass}) {
    $cmd .= " -p$options->{xref_pass}";
  }
  run($cmd);
  close $fh;
  unlink $filename;
}

########################################################
## System calls 
## Wrapper function for system calls
## Params:
## - Command line
## Actions:
## - Runs command, prints out error in case of failure
########################################################

sub run {
  my ($cmd) = @_;
  $Helper->log("Running $cmd\n", 0, 'append_date');
  my $exit_code = system($cmd);
  if ($exit_code != 0) {
    die("Failure when running command\n$cmd\n")
  }
}

