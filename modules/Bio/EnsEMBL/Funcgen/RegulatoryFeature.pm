#
# Ensembl module for Bio::EnsEMBL::Funcgen::RegulatoryFeature
#
# You may distribute this module under the same terms as Perl itself

=head1 NAME

Bio::EnsEMBL::RegulatoryFeature - A module to represent a regulatory feature 
mapping as generated by the eFG regulatory build pipeline.

=head1 SYNOPSIS

use Bio::EnsEMBL::Funcgen::RegulatoryFeature;

my $feature = Bio::EnsEMBL::Funcgen::RegulatoryFeature->new(
	-SLICE         => $chr_1_slice,
	-START         => 1_000_000,
	-END           => 1_000_024,
	-STRAND        => -1,
    -DISPLAY_LABEL => $text,
    -FEATURE_SET   => $fset,
    -FEATURE_TYPE  => $reg_feat_type,
); 



=head1 DESCRIPTION

A RegulatoryFeature object represents the genomic placement of a combined regulatory
feature generated by the eFG analysis pipeline, which may have originated from one or 
many separate annotated or supporting features.

=head1 AUTHOR

This module was created by Nathan Johnson.

This module is part of the Ensembl project: http://www.ensembl.org/

=head1 CONTACT

Post comments or questions to the Ensembl development list: ensembl-dev@ebi.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;

package Bio::EnsEMBL::Funcgen::RegulatoryFeature;

use Bio::EnsEMBL::Utils::Argument qw( rearrange );
use Bio::EnsEMBL::Utils::Exception qw( throw );
use Bio::EnsEMBL::Feature;
use Bio::EnsEMBL::Funcgen::FeatureType;

use vars qw(@ISA);
@ISA = qw(Bio::EnsEMBL::Feature);


=head2 new

 
  Arg [-SCORE]: (optional) int - Score assigned by analysis pipeline
  Arg [-ANALYSIS] : Bio::EnsEMBL::Analysis 
  Arg [-SLICE] : Bio::EnsEMBL::Slice - The slice on which this feature is.
  Arg [-START] : int - The start coordinate of this feature relative to the start of the slice
		 it is sitting on. Coordinates start at 1 and are inclusive.
  Arg [-END] : int -The end coordinate of this feature relative to the start of the slice
	       it is sitting on. Coordinates start at 1 and are inclusive.
  Arg [-DISPLAY_LABEL]: string - Display label for this feature
  Arg [-STRAND]       : int - The orientation of this feature. Valid values are 1, -1 and 0.
  Arg [-FEATURE_SET]  : Bio::EnsEMBL::Funcgen::FeatureSet - Regulatory Feature set
  Arg [-FEATURE_TYPE] : Bio::EnsEMBL::Funcgen::FeatureType - Regulatory Feature sub type
  Arg [-ATTRIBUTES]   : ARRAYREF of attribute features e.g. Annotated or ? Features
  Arg [-dbID]         : (optional) int - Internal database ID.
  Arg [-ADAPTOR]      : (optional) Bio::EnsEMBL::DBSQL::BaseAdaptor - Database adaptor.
  Example    : my $feature = Bio::EnsEMBL::Funcgen::RegulatoryFeature->new(
										                                  -SLICE         => $chr_1_slice,
									                                      -START         => 1_000_000,
									                                      -END           => 1_000_024,
									                                      -STRAND        => -1,
									                                      -DISPLAY_LABEL => $text,
									                                      -FEATURE_SET   => $fset,
                                                                          -FEATURE_TYPE  => $reg_ftype,
                                                                          -REGULATORY_ATTRIBUTES    => \@features,
                                                                         );


  Description: Constructor for RegulatoryFeature objects.
  Returntype : Bio::EnsEMBL::Funcgen::RegulatoryFeature
  Exceptions : None
  Caller     : General
  Status     : At Risk

=cut

sub new {
  my $caller = shift;
	
  my $class = ref($caller) || $caller;
  
  my $self = $class->SUPER::new(@_);
  
  my ($display_label, $fset, $reg_type, $stable_id, $reg_attrs)
    = rearrange(['DISPLAY_LABEL', 'FEATURE_SET', 'FEATURE_TYPE', 'STABLE_ID', 'REGULATORY_ATTRIBUTES'], @_);
  
  #check mandatory params here
  $self->display_label($display_label) if $display_label;
  throw("Must provide a FeatureSet") if ! $fset;
  $self->feature_set($fset);
  throw("Must provide a FeatureType") if ! $reg_type;
  $self->feature_type($reg_type) if $reg_type;
  $self->stable_id($stable_id) if $stable_id;
  $self->regulatory_attributes($reg_attrs) if $reg_attrs;

  #$self->experiment_ids(@$exp_ids);


  #do we need to validate this against the db?  Grab from slice and create new if not present? 
  #Will this be from the dnadb? Or will this work differently for RegulatoryFeatures?
	
  #$self->coord_system_id($coord_sys_id);
	
  return $self;
}

=head2 new_fast

  Args       : Hashref with all internal attributes set
  Example    : none
  Description: Quick and very dirty version of new. Only works if the code is very
               disciplined.
  Returntype : Bio::EnsEMBL::Funcgen::RegulatoryFeature
  Exceptions : None
  Caller     : Bio::EnsEMBL::Funcgen::DBSQL::RegulatoryFeatureAdaptor
  Status     : Medium Risk

=cut

sub new_fast {
  bless ($_[1], $_[0]);
}


=head2 display_label

  Arg [1]    : string - display label
  Example    : my $label = $feature->display_label();
  Description: Getter and setter for the display label of this feature.
  Returntype : String
  Exceptions : None
  Caller     : General
  Status     : Medium Risk

=cut

#this will over ride individual display_label for annotated features.
#set label could be used as track name and feature label used in zmenu?
#These should therefore be called track_label and display_label


sub display_label {
    my $self = shift;
	
    $self->{'display_label'} = shift if @_;


    #auto generate here if not set in table
    #need to go with one or other, or can we have both, split into diplay_name and display_label?
    
    if(! $self->{'display_label'}  && $self->adaptor()){
	  #hardcoded for RegulatoryF Feature here instead of accessing feature_set 
      $self->{'display_label'} = $self->feature_type->name()." Regulatory Feature";
      $self->{'display_label'} .= " - ".$self->cell_type->name() if $self->cell_type->display_name();#?
    }
	
    return $self->{'display_label'};
}




#retrieved and set from slice in _pre_store
#can we move the to Funcgen::Feature?
#will this be used by probe_feature?



=head2 cell_type

  Example    : my $cell_name = $pfeature->cell_type()->name();
  Description: Getter for the cell_type attribute for this feature.
  Returntype : Bio::EnsEMBL::Funcgen:CellType
  Exceptions : None
  Caller     : General
  Status     : At risk

=cut

sub cell_type{
	my $self = shift;

	return $self->feature_set->cell_type();
}

=head2 feature_type

  Example    : my $ft_name = $pfeature->feature_type()->name();
  Description: Getter for the feature_type attribute for this feature.
  Returntype : Bio::EnsEMBL::Funcgen:FeatureType
  Exceptions : None
  Caller     : General
  Status     : At risk

=cut

sub feature_type{
  my $self = shift;
  
  if(@_){
	if(! ($_[0] && $_[0]->isa("Bio::EnsEMBL::Funcgen::FeatureType"))){
	  throw("Must pass valid Bio::EnsEMBL::Funcgen::FeatureType object");
	}

	$self->{'feature_type'} = $_[0];
    }

  return $self->{'feature_type'};
}

=head2 feature_set

  Arg [1]    : (optional) Bio::EnsEMBL::FeatureSet 
  Example    : $pfeature->feature_set($fset);
  Description: Getter and setter for the feature_set attribute for this feature. 
  Returntype : Bio::EnsEMBL::Funcgen::FeatureSet
  Exceptions : Throws is arg is not a valid Bio::EnsEMBL::Funcgen::FeatureSet
  Caller     : General
  Status     : At Risk

=cut

sub feature_set {
    my $self = shift;

    if(@_){
      my $fset = shift;
      if(! ($fset && $fset->isa("Bio::EnsEMBL::Funcgen::FeatureSet"))){
	throw("Must pass valid Bio::EnsEMBL::Funcgen::FeatureSet object");
      }

      $self->{'feature_set'} = $fset;
    }

    return $self->{'feature_set'};
}


=head2 analysis

  Example    : my $analysis = $pfeature->feature_type()->name();
  Description: Getter for the type attribute for this feature.
  Returntype : Bio:EnsEMBL::Funcgen::FeatureType
  Exceptions : Throws if analysis passed is not a valid Bio::EnsEMBL::Analysis
  Caller     : General
  Status     : At risk

=cut

sub analysis{
  my $self = shift;


  #this is to allow multi analysis sets, but the adaptor currently  throws if they are not the same on store
  if(@_){

    if($_[0]->isa("Bio::EnsEMBL::Analysis")){
      $self->{'analysis'} = $_[0];
    }else{
      throw("Must pass a valid Bio::EnsEMBL::Analysis");
    }
    
  }

  return (defined $self->{'analysis'}) ? $self->{'analysis'} : $self->feature_set->analysis();
}


=head2 stable_id

  Arg [1]    : (optional) string - stable_id e.g ENSR00000000001
  Example    : my $stable_id = $feature->stable_id();
  Description: Getter and setter for the stable_id attribute for this feature. 
  Returntype : string
  Exceptions : None
  Caller     : General
  Status     : At Risk

=cut

sub stable_id {
  my $self = shift;
	
  $self->{'stable_id'} = shift if @_;
  
  return $self->{'stable_id'};
}


=head2 regulatory_attributes

  Arg [1]    : (optional) list of constituent features
  Example    : print "Regulatory Attributes:\n\t".join("\n\t", @{$feature->regulatory_attributes()})."\n";
  Description: Getter and setter for the regulatory_attributes for this feature. 
  Returntype : ARRAYREF
  Exceptions : None
  Caller     : General
  Status     : At Risk

=cut


#change to store attrs in type hash?

sub regulatory_attributes {
  my ($self, $attrs) = @_;
	
  #deref here for safety??
  $self->{'regulatory_attributes'} =  [@$attrs] if $attrs;

  #check for isa->Feature here?
  
  return $self->{'regulatory_attributes'};
}



=head2 bound_start

  Example    : my $bound_start = $feature->bound_start();
  Description: Getter for the bound_start attribute for this feature.
               Gives the 5' most start value of the underlying attribute
               features.
  Returntype : string
  Exceptions : None
  Caller     : General
  Status     : At Risk

=cut

sub bound_start {
  my $self = shift;

  $self->_generate_underlying_structure() if(! exists $self->{'bound_start'});
  
  return $self->{'bound_start'};
}

=head2 bound_end

  Example    : my $bound_end = $feature->bound_start();
  Description: Getter for the bound_end attribute for this feature.
               Gives the 3' most end value of the underlying attribute
               features.
  Returntype : string
  Exceptions : None
  Caller     : General
  Status     : At Risk

=cut

sub bound_end {
  my $self = shift;
	
  $self->_generate_underlying_structure() if(! exists $self->{'bound_end'});
  
  return $self->{'bound_end'};
}

=head2 _generate_underlying_structure

  Example    :  $self->_generate_underlying_structure() if(! exists $self->{'bound_end'});
  Description: Getter for the bound_end attribute for this feature.
               Gives the 3' most end value of the underlying attribute
               features.
  Returntype : string
  Exceptions : None
  Caller     : General
  Status     : At Risk

=cut

sub _generate_underlying_structure{
  my $self = shift;

  if(! @{$self->regulatory_attributes()}){
	warn "No underlying regulatory_attribute features to generate comples structure from";
	
	#set to undef so we don't cause too many errors
	$self->{'bound_end'} = undef;
	$self->{'bound_end'} = undef;
  }
  else{
	my (@start_ends);

	map { push @start_ends, $_->start;
		  push @start_ends,   $_->end; } @{$self->regulatory_attributes()};

	sort @start_ends;

	$self->{'bound_end'} = pop @start_ends;
	$self->{'bound_start'} = shift @start_ends;
  }

  return;
}
#other methods
#type!! Add to BaseFeature?  Hard code val in oligo_feature
#analysis? Use AnalsisAdapter here, or leave to caller?
#sources/experiments
#target, tar



1;

