#
# Ensembl module for Bio::EnsEMBL::Funcgen::ResultFeature
#
# You may distribute this module under the same terms as Perl itself

=head1 NAME

Bio::EnsEMBL::Funcgen::ResultFeature - A module to represent a lightweight ResultFeature object

=head1 SYNOPSIS

use Bio::EnsEMBL::Funcgen::ResultFeature;

my $rfeature = Bio::EnsEMBL::Funcgen::ResultFeature->new_fast([$start, $end, $score ]);

my @rfeatures = @{$rset->get_displayable_ResultFeature_by_Slice($slice)};

foreach my $rfeature (@rfeatures){
    my $score = $rfeature->score();
    my $rf_start = $rfeature->start();
    my $rf_end = $rfeature->end();
}

=head1 DESCRIPTION

This is a very sparse class designed to be as lightweight as possible to enable fast rendering in the web browser.
As such only the information absolutely required is contained.  Any a piori information is omitted e.g. seq_region_id, 
this will already be known as ResultFeatures are retrieved via a Slice method in ResultSet via the ResultSetAdaptor, 
likewise with analysis and experimental_chip information.  ResultFeatures are transient objects, in that they are not 
stored in the DB, but are a very small subset of information from the result and oligo_feature tables. ResultFeatures 
should only be generated by the ResultSetAdaptorast here is no parameter checking in place.


=head1 AUTHOR

This module was written by Nathan Johnson.

=head1 CONTACT

Post comments or questions to the Ensembl development list: ensembl-dev@ebi.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;

#Could set global named vars here for element names. Would take more memory

package Bio::EnsEMBL::Funcgen::ResultFeature;

use base ('Bio::EnsEMBL::Feature');

=head2 new_fast

  Args       : Array with attributes start, end, strand, score, probe, result_set_id, winow_size  IN THAT ORDER.
               WARNING: None of these are validated, hence can omit some where not needed
  Example    : none
  Description: Fast and list version of new. Only works if the code is very disciplined.
  Returntype : Bio::EnsEMBL::Funcgen::ResultFeature
  Exceptions : None
  Caller     : ResultSetAdaptor
  Status     : At Risk

=cut

sub new_fast {
  my ($class, @args)  = @_;
  #return bless ($arrayref, $class);

  #Passing arrayref here may cause problems with changing vars after obj creation

  bless \@args, $class;
}




=head2 start

  Example    : my $start = $rf->start();
  Description: Getter of the start attribute for ResultFeature
               objects.
  Returntype : int
  Exceptions : None
  Caller     : General
  Status     : At Risk

=cut

sub start {  $_[0]->[0];}


=head2 end

  Example    : my $start = $rf->end();
  Description: Getter of the end attribute for ResultFeature
               objects.
  Returntype : int
  Exceptions : None
  Caller     : General
  Status     : At Risk

=cut

sub end {  $_[0]->[1];}


#Do we need to chacnge this to strand and have slice strand context, as with start and end

sub strand {  $_[0]->[2];}

=head2 score

  Example    : my $score = $rf->score();
  Description: Getter of the score attribute for ResultFeature
               objects
  Returntype : string/float/double?
  Exceptions : None
  Caller     : General
  Status     : At Risk

=cut

sub score {  $_[0]->[3];}


=head2 probe

  Example    : my $probe = $rf->probe();
  Description: Getter of the probe attribute for ResultFeature
               objects
  Returntype : Bio::EnsEMBL::Funcgen::Probe
  Exceptions : None
  Caller     : General
  Status     : At Risk - This can only be used for Features with window 0.

=cut

#probe_id is currently not available in the result_feature table, so this would be a result/probe_feature query.

sub probe {  $_[0]->[4];}


#The following are only used for storage and retrieval, hence why they are not included in new_fast which is streamlined
#for performance
#These have no validation so all thi smust be done in the caller/storer i.e. the adaptor

sub result_set_id {  $_[0]->[5];}
sub window_size {  $_[0]->[6];}

#May not ever need this
#We pass the slice to store
#Don't want to remap, so don't need furing fetch
sub slice {  $_[0]->[7];}


#Had to reimplement these as they used direct hash calls rather than acessor
#redefined to use accessors to array

sub length {
  my $self = shift;
  return $self->end - $self->start + 1;
}



1;

