#
# Ensembl module for Bio::EnsEMBL::Funcgen::PredictedFeature
#
# You may distribute this module under the same terms as Perl itself

=head1 NAME

Bio::EnsEMBL::PredictedFeature - A module to represent a feature mapping as 
predicted by the eFG pipeline.

=head1 SYNOPSIS

use Bio::EnsEMBL::Funcgen::PredictedFeature;

my $feature = Bio::EnsEMBL::Funcgen::PredictedFeature->new(
	-SLICE         => $chr_1_slice,
	-START         => 1_000_000,
	-END           => 1_000_024,
	-STRAND        => -1,
        -DISPLAY_LABEL => $text,
        -SCORE         => $score,
        -FEATURE_SET   => $fset,
); 



=head1 DESCRIPTION

A PredictedFeature object represents the genomic placement of a prediction
generated by the eFG analysis pipeline, which may have originated from one or many
separate experiments.

=head1 AUTHOR

This module was created by Nathan Johnson.

This module is part of the Ensembl project: http://www.ensembl.org/

=head1 CONTACT

Post comments or questions to the Ensembl development list: ensembl-dev@ebi.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;

package Bio::EnsEMBL::Funcgen::PredictedFeature;

use Bio::EnsEMBL::Utils::Argument qw( rearrange );
use Bio::EnsEMBL::Utils::Exception qw( throw );
use Bio::EnsEMBL::Feature;
use Bio::EnsEMBL::Funcgen::FeatureType;

use vars qw(@ISA);
@ISA = qw(Bio::EnsEMBL::Feature);


=head2 new

 
  Arg [-SCORE]: (optional) int - Score assigned by analysis pipeline
  Arg [-ANALYSIS] : Bio::EnsEMBL::Analysis 
  Arg [-SLICE] : Bio::EnsEMBL::Slice - The slice on which this feature is.
  Arg [-START] : int - The start coordinate of this feature relative to the start of the slice
		 it is sitting on. Coordinates start at 1 and are inclusive.
  Arg [-END] : int -The end coordinate of this feature relative to the start of the slice
	       it is sitting on. Coordinates start at 1 and are inclusive.
  Arg [-DISPLAY_LABEL]: string - Display label for this feature
  Arg [-STRAND]       : int - The orientation of this feature. Valid values are 1, -1 and 0.
  Arg [-dbID]         : (optional) int - Internal database ID.
  Arg [-ADAPTOR]      : (optional) Bio::EnsEMBL::DBSQL::BaseAdaptor - Database adaptor.
  Example    : my $feature = Bio::EnsEMBL::Funcgen::PredictedFeature->new(
										                                  -SLICE         => $chr_1_slice,
									                                      -START         => 1_000_000,
									                                      -END           => 1_000_024,
									                                      -STRAND        => -1,
									                                      -DISPLAY_LABEL => $text,
									                                      -SCORE         => $score,
                                                                          -FEATURE_SET   => $fset,
                                                                         );


  Description: Constructor for PredictedFeature objects.
  Returntype : Bio::EnsEMBL::Funcgen::PredictedFeature
  Exceptions : None
  Caller     : General
  Status     : Medium Risk

=cut

sub new {
  my $caller = shift;
	
  my $class = ref($caller) || $caller;
  
  my $self = $class->SUPER::new(@_);
  
  my ($display_label, $score, $fset)
    = rearrange(['DISPLAY_LABEL', 'SCORE', 'FEATURE_SET'], @_);
  
  #check mandatory params here
 
  $self->score($score) if $score;
  $self->display_label($display_label) if $display_label;
  throw("Must provide a FeatureSet") if ! $fset;
  $self->feature_set($fset);

  #$self->experiment_ids(@$exp_ids);


  #do we need to validate this against the db?  Grab from slice and create new if not present? 
  #Will this be from the dnadb? Or will this work differently for PredictedFeatures?
	
  #$self->coord_system_id($coord_sys_id);
	
  return $self;
}

=head2 new_fast

  Args       : Hashref with all internal attributes set
  Example    : none
  Description: Quick and dirty version of new. Only works if the code is very
               disciplined.
  Returntype : Bio::EnsEMBL::Funcgen::PredictedFeature
  Exceptions : None
  Caller     : General
  Status     : Medium Risk

=cut

sub new_fast {
   my ($class, $hashref)  = @_;


   return bless ($hashref, $class);
}

=head2 score

  Arg [1]    : (optional) int - score
  Example    : my $score = $feature->score();
  Description: Getter and setter for the score attribute for this feature. 
  Returntype : int
  Exceptions : None
  Caller     : General
  Status     : Low Risk

=cut

sub score {
    my $self = shift;
	
    $self->{'score'} = shift if @_;
		
    return $self->{'score'};
}


=head2 feature_set

  Arg [1]    : (optional) Bio::EnsEMBL::FeatureSet 
  Example    : $pfeature->feature_set($fset);
  Description: Getter and setter for the feature_set attribute for this feature. 
  Returntype : Bio::EnsEMBL::Funcgen::FeatureSet
  Exceptions : Throws is arg is not a valid Bio::EnsEMBL::Funcgen::FeatureSet
  Caller     : General
  Status     : At Risk

=cut

sub feature_set {
    my $self = shift;

    if(@_){
      my $fset = shift;
      if(! ($fset && $fset->isa("Bio::EnsEMBL::Funcgen::FeatureSet"))){
	throw("Must pass valid Bio::EnsEMBL::Funcgen::FeatureSet object");
      }

      $self->{'feature_set'} = $fset;
    }

    return $self->{'feature_set'};
}

=head2 display_label

  Arg [1]    : string - display label
  Example    : my $label = $feature->display_label();
  Description: Getter and setter for the display label of this feature.
  Returntype : str
  Exceptions : None
  Caller     : General
  Status     : Medium Risk

=cut

#Can This be mirrored in PredictedFeatureSet?
#this will over ride individual display_label for predicted features.
#set label could be used as track name and feature label used in zmenu?
#These should therefore be called track_label and display_label


sub display_label {
    my $self = shift;
	
    $self->{'display_label'} = shift if @_;


    #auto generate here if not set in table
    #need to go with one or other, or can we have both, split into diplay_name and display_label?
    
    if(! $self->{'display_label'}  && $self->adaptor()){
      $self->{'display_label'} = $self->feature_type->name()." -";
      $self->{'display_label'} .= " ".$self->cell_type->name();# if $self->cell_type->display_name();
      $self->{'display_label'} .= " Enriched Site";
    }
	
    return $self->{'display_label'};
}




#retrieved and set from slice in _pre_store
#can we move the to Funcgen::Feature?
#will this be used by probe_feature?

=head2 coord_system_id

  Arg [1]    : int - dbID of corresponding coord_system for DB of origin
  Example    : $feature->coord_system_id($cs_id);
  Description: Getter and setter for the coord system id for this feature.
  Returntype : int
  Exceptions : None
  Caller     : General
  Status     : Medium

=cut

sub coord_system_id {
    my $self = shift;
	
    $self->{'coord_system_id'} = shift if @_;
	
    return $self->{'coord_system_id'};
}

#All the following can be moved/mirrored in FeatureSet
#data will be in feature set table


=head2 experiment_ids

  Args       : array - experiment ids
  Example    : $feature->experiment_ids(@ids);
  Description: Getter/Setter for the experiment_id attribute for this feature.
  Returntype : listref
  Exceptions : None
  Caller     : General
  Status     : Medium
             
=cut

#sub experiment_ids {
#  my ($self, @ids) = @_;

#  $self->{'experiment_ids'} = \@ids if @ids;

#  return $self->{'experiment_ids'};
#}


=head2 cell_type

  Example    : my $cell_name = $pfeature->cell_type()->name();
  Description: Getter for the cell_type attribute for this feature.
  Returntype : Bio::EnsEMBL::Funcgen:CellType
  Exceptions : None
  Caller     : General
  Status     : At risk

=cut

sub cell_type{
	my $self = shift;

	return $self->feature_set->cell_type();
}

=head2 feature_type

  Example    : my $ft_name = $pfeature->feature_type()->name();
  Description: Getter for the feature_type attribute for this feature.
  Returntype : Bio::EnsEMBL::Funcgen:FeatureType
  Exceptions : None
  Caller     : General
  Status     : At risk

=cut

sub feature_type{
  my $self = shift;
  
  return $self->feature_set->feature_type();
}


#redefined from Feature to use FeatureSet, unless specifically set

=head2 analysis

  Example    : my $analysis = $pfeature->feature_type()->name();
  Description: Getter for the type attribute for this feature.
  Returntype : Bio:EnsEMBL::Funcgen::FeatureType
  Exceptions : Throws if analysis passed is not a valid Bio::EnsEMBL::Analysis
  Caller     : General
  Status     : At risk

=cut

sub analysis{
  my $self = shift;


  #this is to allow multi analysis sets, but the adaptor currently  throws if they are not the same on store
  if(@_){

    if($_[0]->isa("Bio::EnsEMBL::Analysis")){
      $self->{'analysis'} = $_[0];
    }else{
      throw("Must pass a valid Bio::EnsEMBL::Analysis");
    }
    
  }

  return (defined $self->{'analysis'}) ? $self->{'analysis'} : $self->feature_set->analysis();
}


#can be moved/mirrored to/in feature set?

#sub type {
#  my $self = shift;
#
#  #$self->{'type'} = shift if @_;
#  my ($name, $desc, $ft);	
#
#  if( ! $self->{'type'}){
#
#    if($self->{'feature_type_id'} && $self->adaptor()){
#
#      $self->{'type'} = $self->adaptor->db->get_FeatureTypeAdaptor->fetch_by_dbID($self->{'feature_type_id'});
#
#
#    }else{#hacky interim solution, need to implement cell line look up and display name method in pft? clashes will display_label?
#
#
#   
#      my %desc_hack  = (
#			1  => "Histone 3 Lysine 9 Acetylation",
#			2  => "Histone 4 Acetylation",
#			3  => "Histone 3 Acetylation",
#			4  => "Histone 3 Lysine 4 Tri-Methylation",
#			5  => "Histone 3 Lysine 4 Di-Methylation",
#			6  => "Histone 3 Lysine 4 Mono-Methylation",
#			7  => "Histone 3 Lysine 4 Mono-Methylation",
#			8  => "Histone 3 Lysine 4 Di-Methylation",
#			9  => "Histone 3 Acetylation",
#			10 => "Histone 4 Acetylation",
#			11 => "Histone 3 Lysine 4 Tri-Methylation",
#		       );
#      
#      my %name_hack = (
#		       1  => "H3K9ac - U2OS Enriched Sites",
#		       2  => "H4ac - HeLa Enriched Sites",
#		       3  => "H3ac - HeLa Enriched Sites",
#		       4  => "H3K4me3 - HeLa Enriched Sites",
#		       5  => "H3K4me2 - HeLa Enriched Sites",
#		       6  => "H3K4me1 - HeLa Enriched Sites",
#		       7  => "H3K4me1 - GM06990 Enriched Sites",
#		       8  => "H3K4me2 - GM06990 Enriched Sites",
#		       9  => "H3ac - GM06990 Enriched Sites",
#		       10 => "H4ac - GM06990 Enriched Sites",
#		       11 => "H3K4me3 - GM06990 Enriched Sites",
#		      );
#      
#      
#      
#      if($self->adaptor->db->species() =~ /homo/i){
#	my $exp_id = shift @{$self->experiment_ids()};
#	$desc = $desc_hack{$exp_id};
#	$name = $name_hack{$exp_id};
#      }else{
#	$desc = "Histone 3 Lysine 9 Tri-methlyation";
#	$name = "H3K4Me3 - MEFf Enriched Sites";
#      }
#      
#      $ft = Bio::EnsEMBL::Funcgen::FeatureType->new
#	(
#	 -NAME => $name,
#	 -DESCRIPTION => $desc,
#	 -CLASS => "HISTONE", 
#	); 
#    }
#    
#    $self->{'type'} = $ft;
#    }
#  
#  return $self->{'type'};
#}




#other methods
#type!! Add to BaseFeature?  Hard code val in oligo_feature
#analysis? Use AnalsisAdapter here, or leave to caller?
#sources/experiments
#target, tar



1;

