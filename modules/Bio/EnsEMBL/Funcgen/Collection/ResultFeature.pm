#
# Ensembl module for Bio::EnsEMBL::Funcgen::Collection::ResultFeature
#
# You may distribute this module under the same terms as Perl itself

=head1 NAME

Bio::EnsEMBL::Funcgen::Collection::ResultFeature - A module to represent a lightweight ResultFeature collection

=head1 SYNOPSIS

use Bio::EnsEMBL::Funcgen::Collection::ResultFeature;


#NEEDS updating

my $rfeature = Bio::EnsEMBL::Funcgen::Collection::ResultFeature->new_fast([$start, $end, $score ]);

my @rfeatures = @{$rset->get_displayable_ResultFeatures_by_Slice($slice)};

foreach my $rfeature (@rfeatures){
    my $score = $rfeature->score();
    my $rf_start = $rfeature->start();
    my $rf_end = $rfeature->end();
}

=head1 DESCRIPTION

This is a very sparse class designed to be as lightweight as possible to enable fast rendering in the web browser.
As such only the information absolutely required is contained.  Any a piori information is omitted e.g. seq_region_id, 
this will already be known as ResultFeatures are retrieved via a Slice method in ResultSet via the ResultSetAdaptor, 
likewise with analysis and experimental_chip information.  ResultFeatures are transient objects, in that they are not 
stored in the DB, but are a very small subset of information from the result and oligo_feature tables. ResultFeatures 
should only be generated by the ResultSetAdaptor as there is no parameter checking in place.

=cut

#This is distinct from a normal feature as the collection may have differen attributes and methods from the normal feature
#implementation.  For example a Bio::EnsEMBL::Collection::Gene would only have summary information over several genes.
#Altho', unlikely that we'll ever collect genes.



use strict;
use warnings;

#Could set global named vars here for element names. Would take more memory

package Bio::EnsEMBL::Funcgen::Collection::ResultFeature;
#If the data model permits this also be the default object for the natural resolution object
#i.e. we can get rid of Bio::EnsEMBL::Funcgen::ResultFeature
#This is particularly applicable to features where the natural resoltion and the bins can be 
#stored in the same table

use base ('Bio::EnsEMBL::Feature');

#Need to define method/attr order here to enable new_fast?
#Altho this sort on a feature by feature basis would negate any speed increases of new_fast method?
#Need to benchmark this.


=head2 new_fast

  Args       : Array with attributes start, end, strand, scores, probe, result_set_id, winow_size, slice  IN THAT ORDER.
               WARNING: None of these are validated, hence can omit some where not needed
  Example    : none
  Description: Fast and list version of new. Only works if the code is very disciplined.
  Returntype : Bio::EnsEMBL::Funcgen::ResultFeature
  Exceptions : None
  Caller     : ResultSetAdaptor
  Status     : At Risk

=cut

#To do
# Re/Move probe to end?
# turn back into hash as we are only ever returning one of these?
# Then we can super new and get rid of most of these methods?
# Just do with current implementation for now.

sub new_fast {
  my ($class, @args)  = @_;
  #return bless ($arrayref, $class);

  #Passing arrayref here may cause problems with changing vars after obj creation

  #warn "in new fast with @args";
 
  #unshift @args, undef;#This would mean we can't set slice in new_fast?

  bless \@args, $class;
}


#have separate get and set method to avoid test when getting attrs?
#or do we need these for some base feature methods..project?
#Will we ever want to project these? Just project original features
# and recompute collections?
#What about projecting between levels rather than assemblies?

=head2 start

  Example    : my $start = $rf->start();
  Description: Getter of the start attribute for ResultFeature
               objects.
  Returntype : int
  Exceptions : None
  Caller     : General
  Status     : At Risk - Now also sets to enable projection

=cut

sub start {  
  $_[0]->[0] =  $_[1] if $_[1];
  $_[0]->[0];
}


=head2 end

  Example    : my $start = $rf->end();
  Description: Getter of the end attribute for ResultFeature
               objects.
  Returntype : int
  Exceptions : None
  Caller     : General
  Status     : At Risk - Now also sets to enable projection

=cut

sub end {  
  $_[0]->[1] =  $_[1] if $_[1];
  $_[0]->[1];
}

=head2 strand

  Example    : my $strand = $rf->strand();
  Description: Getter of the strand attribute for ResultFeature objects
  Returntype : int - -1|0|1
  Exceptions : None
  Caller     : General
  Status     : At Risk

=cut

#Do we need to change this to strand and have slice strand context, as with start and end

sub strand {  $_[0]->[2];}

=head2 scores

  Example    : my $score = $rf->score();
  Description: Getter of the scores attribute for ResultFeature
               objects
  Returntype : Arrayref.
  Exceptions : None
  Caller     : General
  Status     : At Risk

=cut

sub scores {  $_[0]->[3];}


=head2 probe

  Example    : my $probe = $rf->probe();
  Description: Getter of the probe attribute for ResultFeature
               objects
  Returntype : Bio::EnsEMBL::Funcgen::Probe
  Exceptions : None
  Caller     : General
  Status     : At Risk - This can only be used for Features with window 0.

=cut

#probe_id is currently not available in the result_feature table, so this would be a result/probe_feature query.

sub probe {  $_[0]->[4];}


#The following are only used for storage and retrieval, hence why they are not included in new_fast which is streamlined
#for performance
#These have no validation so all thi smust be done in the caller/storer i.e. the adaptor

sub result_set_id {  $_[0]->[5];}
sub window_size {  $_[0]->[6];}

#May not ever need this
#We pass the slice to store
#Don't normally want to remap, so don't need during fetch
#Now also sets for to enable projection

#We should set this as 0!
#So we are not shunting it?

sub slice {  
  $_[0]->[7] =  $_[1] if $_[1];
  $_[0]->[7];
}


#Had to reimplement these as they used direct hash calls rather than acessor
#redefined to use accessors to array

#Define these in base Bio::EnsEMBL::Collection if we want to use arrays as default?


sub length {
  my $self = shift;
  return $self->end - $self->start + 1;
}

=head2 move

  Arg [1]    : int start
  Arg [2]    : int end
  Arg [3]    : (optional) int strand
  Example    : None
  Description: Sets the start, end and strand in one call rather than in 
               3 seperate calls to the start(), end() and strand() methods.
               This is for convenience and for speed when this needs to be
               done within a tight loop.
  Returntype : none
  Exceptions : Thrown is invalid arguments are provided
  Caller     : general
  Status     : Stable

=cut

sub move {
  my $self = shift;

  throw('start and end arguments are required') if(@_ < 2);

  my $start  = shift;
  my $end    = shift;
  my $strand = shift;

  if(defined($start) && defined($end) && $end < $start) {
    throw('start must be less than or equal to end');
  }
  if(defined($strand) && $strand != 0 && $strand != -1 && $strand != 1) {
    throw('strand must be 0, -1 or 1');
  }

  $self->[0] = $start;
  $self->[1] = $end;
  $self->[2] = $strand if(defined($strand));
}



=head2 feature_Slice

  Args       : none
  Example    : $slice = $feature->feature_Slice()
  Description: Reimplementation of Bio::EnsEMBL::Feature method to enable
               assembly mapping
  Returntype : Bio::EnsEMBL::Slice or undef if this feature has no attached
               Slice.
  Exceptions : warning if Feature does not have attached slice.
  Caller     : web drawing code
  Status     : Stable

=cut


sub feature_Slice {
  my ($self) = @_;

  my $slice = $self->[7];

  if(!$slice) {
    warning('Cannot obtain Feature_Slice for feature without attached slice');
    return undef;
  }

  return $slice->sub_Slice($self->[0], $self->[1]); 
}



1;

